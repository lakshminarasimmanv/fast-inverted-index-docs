"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1703],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>d});var s=t(6540);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},9988:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"thread-safety","title":"Thread Safety","description":"This document details the thread safety guarantees and implementation strategy in the Fast Inverted Index library, focusing on the Rust core and Python bindings.","source":"@site/docs/thread_safety.md","sourceDirName":".","slug":"/thread-safety","permalink":"/docs/thread-safety","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/thread_safety.md","tags":[],"version":"current","frontMatter":{"id":"thread-safety","title":"Thread Safety","sidebar_label":"Thread Safety"},"sidebar":"docs","previous":{"title":"Memory Management","permalink":"/docs/memory-management"},"next":{"title":"Document Content Storage","permalink":"/docs/document-content-storage"}}');var r=t(4848),i=t(8453);const a={id:"thread-safety",title:"Thread Safety",sidebar_label:"Thread Safety"},d="Thread Safety in Fast Inverted Index",o={},l=[{value:"Thread Safety Guarantees",id:"thread-safety-guarantees",level:2},{value:"Implementation Strategy",id:"implementation-strategy",level:2},{value:"Rust Core",id:"rust-core",level:3},{value:"Python Bindings",id:"python-bindings",level:3},{value:"Example Usage",id:"example-usage",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Thread Safety Testing",id:"thread-safety-testing",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"thread-safety-in-fast-inverted-index",children:"Thread Safety in Fast Inverted Index"})}),"\n",(0,r.jsx)(n.p,{children:"This document details the thread safety guarantees and implementation strategy in the Fast Inverted Index library, focusing on the Rust core and Python bindings."}),"\n",(0,r.jsx)(n.h2,{id:"thread-safety-guarantees",children:"Thread Safety Guarantees"}),"\n",(0,r.jsx)(n.p,{children:"Fast Inverted Index provides the following thread safety guarantees:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Concurrent Reading"}),": Multiple threads can safely read from the same index simultaneously without any locking or coordination."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Concurrent Reading and Writing"}),": Reader threads can safely access the index while writer threads are modifying it. The library uses a combination of RwLock and mutation guards to ensure consistency."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mutation Operations"}),": All mutation operations (adding documents, removing documents, optimizing, etc.) are thread-safe, using appropriate locking mechanisms to prevent conflicts."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parallel Operations"}),": Parallel indexing, searching, and optimization utilize thread pools efficiently while maintaining thread safety."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-strategy",children:"Implementation Strategy"}),"\n",(0,r.jsx)(n.h3,{id:"rust-core",children:"Rust Core"}),"\n",(0,r.jsx)(n.p,{children:"The Rust core implementation uses several mechanisms to ensure thread safety:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arc-RwLock Pattern"}),": Core data structures are wrapped in ",(0,r.jsx)(n.code,{children:"Arc"})," (Atomic Reference Counting) and ",(0,r.jsx)(n.code,{children:"RwLock"})," (Read-Write Lock) to allow safe concurrent access."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mutation Lock"}),": A dedicated ",(0,r.jsx)(n.code,{children:"mutation_lock"})," is used for atomic operations that modify the index structure."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Field-Specific Locks"}),": Each field has its own locks to minimize contention when multiple threads access different fields."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Immutable Data Structures"}),": Where possible, immutable data structures are used to allow lock-free reading."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Thread-Local Caches"}),": Performance-critical components use thread-local caches to reduce lock contention."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"python-bindings",children:"Python Bindings"}),"\n",(0,r.jsx)(n.p,{children:"In version 0.4.5, we significantly improved thread safety in the Python bindings:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Dual-Approach Pattern"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fast Path"}),": When exclusive access is available, ",(0,r.jsx)(n.code,{children:"Arc::get_mut()"})," is used for maximum performance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Thread-Safe Path"}),": When multiple references exist, the code falls back to using the ",(0,r.jsx)(n.code,{children:"mutation_lock"})," for guaranteed thread safety."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Method Requirements"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Methods requiring mutability such as ",(0,r.jsx)(n.code,{children:"add_documents_with_fields_parallel"})," are defined with ",(0,r.jsx)(n.code,{children:"&mut self"})," to ensure proper access patterns."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Thread safety errors are properly converted to Python exceptions with clear error messages."}),"\n",(0,r.jsxs)(n.li,{children:["Storage operation errors are consistently handled using the ",(0,r.jsx)(n.code,{children:"to_py_err"})," function."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.p,{children:"Here's an example of safely using the library in a multithreaded Python environment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import concurrent.futures\nfrom fast_inverted_index import Index, Schema, FieldSchema\n\n# Create schema and index\nschema = Schema()\nschema.add_field(FieldSchema.text("content"))\nindex = Index(in_memory=True, schema=schema)\n\n# Add documents concurrently\ndef add_document(doc_id, content):\n    return index.add_document(doc_id, content)\n\n# Search concurrently\ndef search_index(term):\n    return index.search(term)\n\n# Run multiple operations concurrently\nwith concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor:\n    # Add documents (thread-safe)\n    add_futures = [executor.submit(add_document, i, f"Document {i}") \n                  for i in range(1, 101)]\n    \n    # Wait for additions to complete\n    concurrent.futures.wait(add_futures)\n    \n    # Perform searches concurrently (thread-safe)\n    search_futures = [executor.submit(search_index, f"document") \n                     for _ in range(20)]\n    \n    # Wait for all searches to complete\n    results = concurrent.futures.wait(search_futures)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsx)(n.p,{children:"The thread safety implementation uses several key techniques:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lock Granularity"}),": Instead of a global lock, locks are applied at appropriate levels (dictionary, postings, documents) to minimize contention."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lock-Free Reading"}),": Reads don't require any exclusive locks, allowing high-concurrency read operations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Atomic Operations"}),": Complex multi-step operations use the mutation lock to ensure atomicity."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fallback Strategy"}),": If fast-path operations aren't possible due to multiple references, the code falls back to using thread-safe but potentially slower paths."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"thread-safety-testing",children:"Thread Safety Testing"}),"\n",(0,r.jsx)(n.p,{children:"We've implemented comprehensive thread safety tests:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Unit Tests"}),": Dedicated thread safety tests that verify concurrent behavior."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Stress Tests"}),": High-concurrency operations to identify subtle thread safety issues."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Mixed Operations"}),": Tests that combine reads, writes, and maintenance operations to verify real-world thread safety."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.p,{children:"Thread safety has minimal impact on performance in most scenarios:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Read Operations"}),": No additional overhead for read-only operations."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Single-Writer"}),": When only one thread is writing, the fast path is automatically used."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multiple Writers"}),": When multiple threads write concurrently, the mutex-based approach ensures safety with some performance impact."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lock Contention"}),": The implementation minimizes lock contention by using fine-grained locks and optimistic locking where possible."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);