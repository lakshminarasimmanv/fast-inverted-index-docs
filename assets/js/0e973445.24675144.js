"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8346],{5789:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>t,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"text-field-search","title":"Text Field Search","description":"This document provides an in-depth explanation of how text field searches work in Fast Inverted Index, particularly focusing on how analyzers are applied during indexing and searching.","source":"@site/docs/text_field_search.md","sourceDirName":".","slug":"/text-field-search","permalink":"/fast-inverted-index-docs/docs/text-field-search","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/text_field_search.md","tags":[],"version":"current","frontMatter":{"id":"text-field-search","title":"Text Field Search","sidebar_label":"Text Field Search"},"sidebar":"docs","previous":{"title":"Parallel Indexing","permalink":"/fast-inverted-index-docs/docs/parallel-indexing"},"next":{"title":"Configuration","permalink":"/fast-inverted-index-docs/docs/configuration"}}');var r=i(4848),a=i(8453);const t={id:"text-field-search",title:"Text Field Search",sidebar_label:"Text Field Search"},l="Text Field Search Behavior",d={},o=[{value:"Overview",id:"overview",level:2},{value:"Text Field Analysis Pipeline",id:"text-field-analysis-pipeline",level:2},{value:"Available Analyzers",id:"available-analyzers",level:2},{value:"Analyzer Application During Indexing",id:"analyzer-application-during-indexing",level:2},{value:"Analyzer Application During Searching",id:"analyzer-application-during-searching",level:2},{value:"How This Enables Flexible Search",id:"how-this-enables-flexible-search",level:2},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Configuring Field Analyzers",id:"configuring-field-analyzers",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"text-field-search-behavior",children:"Text Field Search Behavior"})}),"\n",(0,r.jsx)(n.p,{children:"This document provides an in-depth explanation of how text field searches work in Fast Inverted Index, particularly focusing on how analyzers are applied during indexing and searching."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"Fast Inverted Index supports different field types, each with specialized search behaviors:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Text fields"}),": Apply analyzers for tokenization, normalization, and filtering"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keyword fields"}),": Treat values as single tokens with minimal processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Numeric, Date, Boolean fields"}),": Apply specialized processing and comparison logic"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This document focuses on ",(0,r.jsx)(n.strong,{children:"text fields"}),", which have the most complex search behavior."]}),"\n",(0,r.jsx)(n.h2,{id:"text-field-analysis-pipeline",children:"Text Field Analysis Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"Text fields go through an analysis pipeline that consists of:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tokenization"}),": Breaking text into individual tokens (words)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Filtering"}),": Removing unwanted tokens (e.g., stopwords)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Normalization"}),": Transforming tokens (e.g., lowercasing, stemming)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This pipeline is applied both during document indexing and during query processing."}),"\n",(0,r.jsx)(n.h2,{id:"available-analyzers",children:"Available Analyzers"}),"\n",(0,r.jsx)(n.p,{children:"Fast Inverted Index provides several built-in analyzers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Standard Analyzer"}),": Performs whitespace tokenization and lowercase normalization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simple Analyzer"}),": Adds stopword removal to the standard analyzer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keyword Analyzer"}),": Treats the entire input as a single token (used for keyword fields)"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"analyzer-application-during-indexing",children:"Analyzer Application During Indexing"}),"\n",(0,r.jsx)(n.p,{children:"When a document is added to the index with a text field (e.g., \"author\"), the field's content goes through the field's analyzer:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Original: "Jane Smith"\nTokenization: ["Jane", "Smith"]\nFiltering: ["Jane", "Smith"] (no stopwords)\nNormalization: ["jane", "smith"] (lowercased)\n'})}),"\n",(0,r.jsx)(n.p,{children:"These tokens are then indexed with their field prefix, position information, and document ID."}),"\n",(0,r.jsx)(n.h2,{id:"analyzer-application-during-searching",children:"Analyzer Application During Searching"}),"\n",(0,r.jsx)(n.p,{children:"When searching a text field, Fast Inverted Index applies the same analyzer to the search query:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Query: "Jane Smith"\nTokenization: ["Jane", "Smith"]\nFiltering: ["Jane", "Smith"] (no stopwords)\nNormalization: ["jane", "smith"] (lowercased)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Then, the search engine determines how to handle the tokens:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Single token"}),": Creates a term query for that token"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Example: If the query is "Jane", it searches for the token "jane"'}),"\n",(0,r.jsx)(n.li,{children:'This will match any document containing "jane" in the appropriate field'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multiple tokens"}),": Creates a phrase query with the tokens"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Example: If the query is "Jane Smith", it searches for the phrase "jane smith"'}),"\n",(0,r.jsx)(n.li,{children:"This performs an exact phrase match (tokens must appear in the same order)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"how-this-enables-flexible-search",children:"How This Enables Flexible Search"}),"\n",(0,r.jsx)(n.p,{children:"This approach provides several advantages:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Case-insensitive search"}),": Since both document fields and queries are normalized (typically lowercased), searches are case-insensitive by default"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Partial name matching"}),': When searching for "Jane" in the author field, documents with "Jane Smith" will match because the token "jane" is present']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exact phrase matching"}),': When searching for the full phrase "Jane Smith", only documents with that exact phrase (after analysis) will match']}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multiple-token name handling"}),': Names with three parts like "Robert Johnson Smith" can be searched by any combination: "Robert", "Johnson", "Smith", "Robert Johnson", etc.']}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,r.jsx)(n.p,{children:'Consider a document with author field "Robert Johnson Smith":'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Search for "robert" -> \u2705 Matches (single token match)'}),"\n",(0,r.jsx)(n.li,{children:'Search for "johnson" -> \u2705 Matches (single token match)'}),"\n",(0,r.jsx)(n.li,{children:'Search for "smith" -> \u2705 Matches (single token match)'}),"\n",(0,r.jsx)(n.li,{children:'Search for "Robert Johnson" -> \u2705 Matches (exact phrase match)'}),"\n",(0,r.jsx)(n.li,{children:'Search for "Smith Johnson" -> \u274c No match (wrong order)'}),"\n",(0,r.jsx)(n.li,{children:'Search for "Robert Smith" -> \u274c No match (tokens not adjacent)'}),"\n",(0,r.jsx)(n.li,{children:'Search for "robert johnson smith" -> \u2705 Matches (exact phrase match)'}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"configuring-field-analyzers",children:"Configuring Field Analyzers"}),"\n",(0,r.jsx)(n.p,{children:"When creating a schema, you can specify which analyzer to use for each field:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'schema = Schema()\n# Use standard analyzer (default)\nschema.add_field(FieldSchema.text("title"))\n# Explicitly specify simple analyzer with stopword removal\nschema.add_field(FieldSchema.text("description", analyzer=AnalyzerType.SIMPLE))\n# Use keyword analyzer for exact matching\nschema.add_field(FieldSchema.keyword("category"))\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Text field searches are more expensive than keyword searches due to tokenization"}),"\n",(0,r.jsx)(n.li,{children:"Phrase queries are more expensive than single-term queries"}),"\n",(0,r.jsx)(n.li,{children:"Consider using keyword fields for values that should be matched exactly"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Text field search in Fast Inverted Index offers a powerful and flexible way to search through text content with intuitive semantics. The consistent application of analyzers during both indexing and searching ensures predictable results that match users' expectations."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var s=i(6540);const r={},a=s.createContext(r);function t(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);