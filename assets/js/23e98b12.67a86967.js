"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[1187],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(6540);const i={},o=t.createContext(i);function s(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(o.Provider,{value:n},e.children)}},8523:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"query-engine","title":"Query Engine","description":"The Query Engine is a powerful component that provides advanced query capabilities for the inverted index. It introduces a query DSL (Domain Specific Language) for building complex queries with flexible scoring options.","source":"@site/docs/query_engine.md","sourceDirName":".","slug":"/query-engine","permalink":"/docs/query-engine","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/query_engine.md","tags":[],"version":"current","frontMatter":{"id":"query-engine","title":"Query Engine","sidebar_label":"Query Engine"},"sidebar":"docs","previous":{"title":"schema","permalink":"/docs/schema"},"next":{"title":"query uuilder","permalink":"/docs/query-builder"}}');var i=r(4848),o=r(8453);const s={id:"query-engine",title:"Query Engine",sidebar_label:"Query Engine"},a="Query Engine",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Rust API",id:"rust-api",level:2},{value:"QueryNode",id:"querynode",level:3},{value:"QueryExecutor and QueryEngine",id:"queryexecutor-and-queryengine",level:3},{value:"Combining with the Index API",id:"combining-with-the-index-api",level:3},{value:"QueryBuilder",id:"querybuilder",level:3},{value:"Python API",id:"python-api",level:2},{value:"QueryNode and Value Classes",id:"querynode-and-value-classes",level:3},{value:"Query Execution",id:"query-execution",level:3},{value:"Convenience Methods",id:"convenience-methods",level:3},{value:"Advanced Examples",id:"advanced-examples",level:2},{value:"Complex Query with Field Boosting",id:"complex-query-with-field-boosting",level:3},{value:"Date Range Query",id:"date-range-query",level:3},{value:"Combining Text Search with Filtering",id:"combining-text-search-with-filtering",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"BM25 and BM25L Scoring",id:"bm25-and-bm25l-scoring",level:2},{value:"Non-Negative Scoring Guarantee",id:"non-negative-scoring-guarantee",level:3},{value:"Zero Scores for High-Frequency Terms",id:"zero-scores-for-high-frequency-terms",level:4},{value:"Field-Specific Searching",id:"field-specific-searching",level:2},{value:"Rust API for Field Searching",id:"rust-api-for-field-searching",level:3},{value:"Python API for Field Searching",id:"python-api-for-field-searching",level:3},{value:"Combined Boosts Calculation",id:"combined-boosts-calculation",level:3},{value:"Field Score Normalization",id:"field-score-normalization",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"query-engine",children:"Query Engine"})}),"\n",(0,i.jsx)(n.p,{children:"The Query Engine is a powerful component that provides advanced query capabilities for the inverted index. It introduces a query DSL (Domain Specific Language) for building complex queries with flexible scoring options."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The Query Engine provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A flexible query node tree structure for complex queries"}),"\n",(0,i.jsx)(n.li,{children:"Support for term, phrase, prefix, fuzzy, and range queries"}),"\n",(0,i.jsx)(n.li,{children:"Boolean operators (AND, OR, NOT) for combining queries"}),"\n",(0,i.jsx)(n.li,{children:"Field-specific searching with boosting"}),"\n",(0,i.jsx)(n.li,{children:"Multiple scoring algorithms (TF-IDF, BM25, BM25L, Learning-to-Rank)"}),"\n",(0,i.jsx)(n.li,{children:"Score explanation system for debugging and understanding relevance"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"rust-api",children:"Rust API"}),"\n",(0,i.jsx)(n.h3,{id:"querynode",children:"QueryNode"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"QueryNode"})," enum represents different types of queries that can be composed into a tree structure:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important Note about Range Queries"}),": When creating range queries, always use the direct field name (e.g., ",(0,i.jsx)(n.code,{children:'"word_count"'}),") and not the nested path (e.g., ",(0,i.jsx)(n.code,{children:'"metadata.word_count"'}),'), even though the field may appear nested in document structure. Using nested paths (like "metadata.field_name") with range queries will not return the expected results.']}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Create a simple term query\nlet query = QueryNode::term("content", "search");\n\n// Create a boosted term query\nlet query = QueryNode::term_with_boost("title", "search", 2.0);\n\n// Create a phrase query with slop (words can be up to 2 positions apart)\nlet query = QueryNode::phrase("content", vec!["fast", "search"], 2);\n\n// Create a prefix query (matches words starting with "prog")\nlet query = QueryNode::prefix("content", "prog");\n\n// Create a fuzzy query (allowing 1 edit distance)\nlet query = QueryNode::fuzzy("content", "search", 1);\n\n// Create a range query for numeric field (documents with 100-500 words)\n// IMPORTANT: Use direct field name, not the nested path shown in document structure\nlet query = QueryNode::range(\n    "word_count",  // Use direct field name, not "metadata.word_count"\n    Bound::Included(Value::Integer(100)), \n    Bound::Excluded(Value::Integer(500))\n);\n\n// Combine with boolean operators\nlet query = QueryNode::and(vec![\n    QueryNode::term("content", "search"),\n    QueryNode::term("title", "engine"),\n]);\n\n// NOT query (documents without the term "slow")\nlet query = QueryNode::not(\n    QueryNode::term("content", "slow")\n);\n\n// Filter query (search in content, filtered by category)\nlet query = QueryNode::filter(\n    QueryNode::term("content", "search"),\n    QueryNode::term("category", "technology")\n);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"queryexecutor-and-queryengine",children:"QueryExecutor and QueryEngine"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"QueryExecutor"})," trait defines methods for executing queries against the index, while the ",(0,i.jsx)(n.code,{children:"QueryEngine"})," provides the implementation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Create a query engine for an index\nlet engine = QueryEngine::new(&index);\n\n// Create execution parameters\nlet params = QueryExecutionParams {\n    scoring_algorithm: ScoringAlgorithm::BM25,\n    limit: Some(10),\n    explain: false,\n    ..Default::default()\n};\n\n// Execute a query\nlet result = engine.execute(&query, &params)?;\n\n// Access the scored results\nfor (doc_id, score) in &result.scored_docs {\n    println!("Document {}: score {}", doc_id, score);\n}\n\n// Get explanation for a document\'s score\nlet explanation = engine.explain(&query, doc_id, &params)?;\nprintln!("{}", explanation.to_string_tree());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"combining-with-the-index-api",children:"Combining with the Index API"}),"\n",(0,i.jsx)(n.p,{children:"The Query Engine is designed to work seamlessly with the existing Index API:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Execute a query with BM25 scoring\nlet result = index.execute_query(&query, None)?;\n\n// Execute with custom parameters\nlet params = QueryExecutionParams {\n    scoring_algorithm: ScoringAlgorithm::BM25L,\n    limit: Some(20),\n    field_boosts: {\n        let mut boosts = HashMap::new();\n        boosts.insert("title".to_string(), 2.0);\n        boosts.insert("tags".to_string(), 1.5);\n        boosts\n    },\n    ..Default::default()\n};\n\nlet result = index.execute_query(&query, Some(params))?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"querybuilder",children:"QueryBuilder"}),"\n",(0,i.jsx)(n.p,{children:"A fluent builder API is provided for constructing queries:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let query = QueryBuilder::new()\n    .term("content", "search")\n    .boost(1.5)\n    .build()\n    .unwrap();\n\n// Create a complex query\nlet title_query = QueryBuilder::new()\n    .term("title", "search")\n    .boost(2.0)\n    .build()\n    .unwrap();\n\nlet content_query = QueryBuilder::new()\n    .term("content", "engine")\n    .build()\n    .unwrap();\n\nlet combined_query = QueryBuilder::and(vec![title_query, content_query])\n    .build()\n    .unwrap();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"python-api",children:"Python API"}),"\n",(0,i.jsx)(n.h3,{id:"querynode-and-value-classes",children:"QueryNode and Value Classes"}),"\n",(0,i.jsx)(n.p,{children:"The Python API provides equivalent classes for constructing query nodes:"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important Note about Range Queries"}),": When creating range queries, always use the direct field name (e.g., ",(0,i.jsx)(n.code,{children:'"word_count"'}),") and not the nested path (e.g., ",(0,i.jsx)(n.code,{children:'"metadata.word_count"'}),"), even though the field may appear nested in document structure. Using nested paths with range queries will not return the expected results."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import PyQueryNode, PyValue, PyQueryBound\n\n# Create a simple term query\nquery = PyQueryNode.term("content", "search")\n\n# Create a boosted term query\nquery = PyQueryNode.term("title", "search", boost=2.0)\n\n# Create a phrase query\nquery = PyQueryNode.phrase("content", ["fast", "search"], 2)\n\n# Create a prefix query\nquery = PyQueryNode.prefix("content", "prog")\n\n# Create a fuzzy query\nquery = PyQueryNode.fuzzy("content", "search", 1)\n\n# Create a range query\nstart_bound = PyQueryBound.included(PyValue.integer(100))\nend_bound = PyQueryBound.excluded(PyValue.integer(500))\n# IMPORTANT: Use direct field name, not a nested path like "metadata.word_count"\nquery = PyQueryNode.range("word_count", start_bound, end_bound)\n\n# Combine with boolean operators\nquery = PyQueryNode.and([\n    PyQueryNode.term("content", "search"),\n    PyQueryNode.term("title", "engine")\n])\n\n# NOT query\nquery = PyQueryNode.not(PyQueryNode.term("content", "slow"))\n\n# Filter query\nquery = PyQueryNode.filter(\n    PyQueryNode.term("content", "search"),\n    PyQueryNode.term("category", "technology")\n)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"query-execution",children:"Query Execution"}),"\n",(0,i.jsx)(n.p,{children:"The Python API exposes methods for executing queries:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index, PyQueryNode, PyQueryExecutionParams\n\n# Create an index\nindex = Index(in_memory=True)\n\n# Add some documents\nindex.add_document(1, "This is a test document about search engines")\nindex.add_document(2, "Fast search is important for good user experience")\n\n# Create a query\nquery = PyQueryNode.term("content", "search")\n\n# Execute the query with default parameters\nresult = index.execute_query(query)\n\n# Print the results\nfor doc_id, score in result.scored_docs:\n    print(f"Document {doc_id}: score {score}")\n\n# Execute with custom parameters\nparams = PyQueryExecutionParams(\n    scoring_algorithm="bm25l",\n    explain=True,\n    limit=10\n)\n\nresult = index.execute_query(query, params)\n\n# Get explanations\nexplanations = result.explanations\nif explanations:\n    for doc_id, explanation in explanations.items():\n        print(f"Explanation for document {doc_id}:")\n        print(explanation.to_tree())\n'})}),"\n",(0,i.jsx)(n.h3,{id:"convenience-methods",children:"Convenience Methods"}),"\n",(0,i.jsx)(n.p,{children:"The Index class provides convenience methods for common query patterns:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Search in a specific field\nresults = index.search_field("title", "search", algorithm="bm25", limit=10)\n\n# Search for a phrase\nresults = index.search_phrase("content", ["fast", "search"], slop=2, \n                             algorithm="bm25", limit=10)\n\n# Search multiple fields with different boosts\nfield_values = [\n    ("title", "search", 2.0),\n    ("content", "engine", 1.0),\n    ("tags", "search", 1.5)\n]\nresults = index.search_multi_field(field_values, algorithm="bm25", limit=10)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-examples",children:"Advanced Examples"}),"\n",(0,i.jsx)(n.h3,{id:"complex-query-with-field-boosting",children:"Complex Query with Field Boosting"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index, PyQueryNode, PyQueryExecutionParams\n\n# Create an index\nindex = Index(in_memory=True)\n\n# Add some documents with metadata\nindex.add_document(\n    doc_id=1,\n    content="Fast search engines use inverted indexes for efficient retrieval",\n    metadata={\n        "title": "Understanding Search Engines",\n        "tags": ["search", "indexing", "performance"],\n        "category": "Information Retrieval",\n    }\n)\n\nindex.add_document(\n    doc_id=2,\n    content="Inverted indexes map terms to document IDs for fast lookups",\n    metadata={\n        "title": "Inverted Indexes Explained",\n        "tags": ["indexing", "data structures", "algorithms"],\n        "category": "Information Retrieval",\n    }\n)\n\n# Create a complex query\ntitle_query = PyQueryNode.term("title", "search", boost=2.0)\ncontent_query = PyQueryNode.or([\n    PyQueryNode.term("content", "index"),\n    PyQueryNode.term("content", "search")\n])\ncategory_filter = PyQueryNode.term("category", "Information Retrieval")\n\n# Combine queries with filter\nquery = PyQueryNode.filter(\n    PyQueryNode.or([title_query, content_query]),\n    category_filter\n)\n\n# Create custom execution parameters\nparams = PyQueryExecutionParams(\n    scoring_algorithm="bm25",\n    explain=True,\n    limit=10,\n    field_boosts={"title": 1.5, "tags": 1.2}\n)\n\n# Execute the query\nresult = index.execute_query(query, params)\n\n# Process results\nprint(f"Found {result.len()} results in {result.time_ms:.2f}ms")\nfor doc_id, score in result.scored_docs:\n    doc = index.get_document(doc_id)\n    print(f"- {doc[\'title\']} (Score: {score:.4f})")\n    \n    # Show explanation if available\n    if result.explanations and doc_id in result.explanations:\n        explanation = result.explanations[doc_id]\n        print(f"  Explanation: {explanation.description}")\n        print(f"  Score components: {len(explanation.details)} factors")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"date-range-query",children:"Date Range Query"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import time\nfrom fast_inverted_index import Index, PyQueryNode, PyValue, PyQueryBound\n\n# Create an index\nindex = Index(in_memory=True)\n\n# Add documents with timestamps\ncurrent_time = int(time.time())\none_day = 24 * 60 * 60\n\nfor i in range(10):\n    timestamp = current_time - (i * one_day)  # Each doc is one day older\n    index.add_document(\n        doc_id=i+1,\n        content=f"Document created on day {i}",\n        metadata={\n            "title": f"Document {i+1}",\n            "created_at": timestamp\n        }\n    )\n\n# Create a range query for documents from the last 3 days\nthree_days_ago = current_time - (3 * one_day)\nstart_bound = PyQueryBound.included(PyValue.integer(three_days_ago))\nend_bound = PyQueryBound.unbounded()\n\n# Note: Always use the direct field name, not a nested path\ndate_query = PyQueryNode.range("created_at", start_bound, end_bound)\n\n# Execute the query\nresult = index.execute_query(date_query)\n\n# Show the results\nprint(f"Documents from the last 3 days: {result.len()}")\nfor doc_id, score in result.scored_docs:\n    doc = index.get_document(doc_id)\n    created_days_ago = (current_time - doc["created_at"]) / one_day\n    print(f"- {doc[\'title\']} (created {created_days_ago:.1f} days ago)")\n'})}),"\n",(0,i.jsx)(n.h3,{id:"combining-text-search-with-filtering",children:"Combining Text Search with Filtering"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index, PyQueryNode, PyQueryExecutionParams\n\n# Create an index\nindex = Index(in_memory=True)\n\n# Add some documents with various metadata\nfor i in range(1, 11):\n    # Even IDs are programming docs, odd are cooking docs\n    category = "Programming" if i % 2 == 0 else "Cooking"\n    \n    # Word counts vary by document\n    word_count = 100 + (i * 50)\n    \n    content = ""\n    if category == "Programming":\n        content = "Python is a versatile programming language for many applications."\n    else:\n        content = "Italian pasta recipes are popular in modern cooking."\n    \n    # Add the document with metadata\n    index.add_document(\n        doc_id=i,\n        content=content,\n        metadata={\n            "title": f"{category} Document {i}",\n            "category": category,\n            "metadata": {"word_count": word_count}\n        }\n    )\n\n# Create a query that finds programming documents with "python" \n# and at least 300 words\ntext_query = PyQueryNode.term("content", "python")\n\n# Word count >= 300\nword_count_start = PyQueryBound.included(PyValue.integer(300))\nword_count_end = PyQueryBound.unbounded()\n# Note: Use direct field name "word_count", not "metadata.word_count" \nword_count_query = PyQueryNode.range("word_count", word_count_start, word_count_end)\n\n# Category filter\ncategory_query = PyQueryNode.term("category", "Programming")\n\n# Combine them all\ncombined_query = PyQueryNode.and([\n    text_query,\n    PyQueryNode.filter(word_count_query, category_query)\n])\n\n# Execute the query\nresult = index.execute_query(combined_query)\n\n# Show the results\nprint(f"Found {result.len()} programming documents about Python with 300+ words")\nfor doc_id, _ in result.scored_docs:\n    doc = index.get_document(doc_id)\n    print(f"- {doc[\'title\']} (Words: {doc[\'metadata\'][\'word_count\']})")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Query Complexity"}),": Very complex queries with many nodes can increase execution time. Consider simplifying queries where possible."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Field Boosts"}),": Using many field boosts increases scoring computation time. Focus on the most important fields."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Explanation Generation"}),": Enabling the ",(0,i.jsx)(n.code,{children:"explain"})," parameter adds overhead. Use it for debugging but disable in production."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Scoring Algorithm Selection"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"TF-IDF: Fastest, but less sophisticated"}),"\n",(0,i.jsx)(n.li,{children:"BM25: Good balance of speed and quality"}),"\n",(0,i.jsx)(n.li,{children:"BM25L: Better for varied document lengths, slightly slower"}),"\n",(0,i.jsx)(n.li,{children:"LearningToRank: Most powerful but most computationally expensive"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Caching"}),": The query engine benefits from the index's internal caching. Configure cache parameters appropriately for your workload."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For more information on performance optimization, see the ",(0,i.jsx)(n.a,{href:"/docs/performance",children:"Performance"})," documentation."]}),"\n",(0,i.jsx)(n.h2,{id:"bm25-and-bm25l-scoring",children:"BM25 and BM25L Scoring"}),"\n",(0,i.jsx)(n.p,{children:"The Query Engine implements both BM25 and BM25L ranking algorithms to provide state-of-the-art relevance scoring."}),"\n",(0,i.jsx)(n.h3,{id:"non-negative-scoring-guarantee",children:"Non-Negative Scoring Guarantee"}),"\n",(0,i.jsx)(n.p,{children:"Both BM25 and BM25L algorithms in this library are implemented with a non-negative score guarantee. This means:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"All document scores will be \u2265 0.0, even for terms that appear in most documents"}),"\n",(0,i.jsx)(n.li,{children:"The IDF component is guaranteed to be non-negative, preventing negative contribution from common terms"}),"\n",(0,i.jsx)(n.li,{children:"Term scores and final document scores have a floor of 0.0"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach helps ensure consistent, intuitive ranking behavior, especially when:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A term appears in nearly all documents in the collection"}),"\n",(0,i.jsx)(n.li,{children:"Working with small document collections"}),"\n",(0,i.jsx)(n.li,{children:"Using boolean combinations of term queries"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"zero-scores-for-high-frequency-terms",children:"Zero Scores for High-Frequency Terms"}),"\n",(0,i.jsx)(n.p,{children:"It's important to note that our implementation will produce scores of 0.0 for terms that appear in a large proportion of documents (typically more than 50-55% of the corpus). This is expected behavior after clamping negative IDF values to zero."}),"\n",(0,i.jsx)(n.p,{children:"Through extensive testing with synthetic and real data, we've found:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"When a term's document frequency exceeds approximately 53.5% of the corpus, the raw IDF value becomes negative"}),"\n",(0,i.jsx)(n.li,{children:"After applying our non-negative guarantee, these terms receive scores of 0.0"}),"\n",(0,i.jsx)(n.li,{children:"This behavior is consistent across both BM25 and BM25L algorithms"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach aligns with information retrieval best practices, as extremely common terms provide little discriminative value for ranking."}),"\n",(0,i.jsx)(n.p,{children:"For a detailed explanation and test results, see the BM25L documentation."}),"\n",(0,i.jsx)(n.h2,{id:"field-specific-searching",children:"Field-Specific Searching"}),"\n",(0,i.jsx)(n.p,{children:"The Query Engine provides comprehensive support for field-specific searching, allowing you to direct queries to particular fields and control relevance through boosting."}),"\n",(0,i.jsx)(n.h3,{id:"rust-api-for-field-searching",children:"Rust API for Field Searching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use fast_inverted_index::query::{QueryNode, QueryExecutionParams};\nuse std::collections::HashMap;\n\n// Search in a specific field\nlet title_query = QueryNode::term("title", "search");\n\n// Multi-field search with different boosts\nlet multi_field_query = QueryNode::or(vec![\n    QueryNode::term_with_boost("title", "search", 5.0),  // Title is 5x more important\n    QueryNode::term_with_boost("content", "search", 1.0),  // Content has normal importance\n    QueryNode::term_with_boost("tags", "search", 3.0),  // Tags are 3x more important\n]);\n\n// Execute the query with additional field boosts in the parameters\nlet mut params = QueryExecutionParams::default();\nlet mut field_boosts = HashMap::new();\nfield_boosts.insert("title".to_string(), 2.0);  // Additional 2x boost for title\nfield_boosts.insert("tags".to_string(), 1.5);   // Additional 1.5x boost for tags\nparams.field_boosts = field_boosts;\n\nlet results = index.execute_query(&multi_field_query, Some(params))?;\n'})}),"\n",(0,i.jsx)(n.h3,{id:"python-api-for-field-searching",children:"Python API for Field Searching"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import QueryNode, QueryExecutionParams\n\n# Convenience method for field-specific search\ntitle_results = index.search_field("title", "search", ranking_method="bm25", limit=10)\n\n# Multi-field search with different boosts using QueryNode API\nmulti_field_query = QueryNode.OR([\n    QueryNode.term("title", "search", boost=5.0),   # Title is 5x more important\n    QueryNode.term("content", "search", boost=1.0),  # Content has normal importance\n    QueryNode.term("tags", "search", boost=3.0),    # Tags are 3x more important\n])\n\n# Execute with additional field boosts in the parameters\nparams = QueryExecutionParams(\n    scoring_algorithm="bm25",\n    limit=10,\n    field_boosts={\n        "title": 2.0,  # Additional 2x boost for title\n        "tags": 1.5    # Additional 1.5x boost for tags\n    }\n)\n\nresults = index.execute_query(multi_field_query, params)\n\n# Simple multi-field search with the convenience API\nboost_fields = {\n    "title": 5.0,    # Title is 5x more important\n    "content": 1.0,  # Content has normal importance\n    "tags": 3.0,     # Tags are 3x more important\n}\nsimple_results = index.search("search", ranking_method="bm25", boost_fields=boost_fields)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"combined-boosts-calculation",children:"Combined Boosts Calculation"}),"\n",(0,i.jsx)(n.p,{children:"When using both per-query boosts and global field boosts, the final boost value is calculated as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"final_boost = query_boost * field_boost\n"})}),"\n",(0,i.jsx)(n.p,{children:"For example, if you set:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A query boost of 5.0 on the title field in the query node"}),"\n",(0,i.jsx)(n.li,{children:"A global field boost of 2.0 in the execution parameters"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The final boost for the title field would be 10.0 (5.0 * 2.0)."}),"\n",(0,i.jsx)(n.h3,{id:"field-score-normalization",children:"Field Score Normalization"}),"\n",(0,i.jsx)(n.p,{children:"The Query Engine ensures that field scores are properly normalized so that:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Matches across all fields contribute to the final score"}),"\n",(0,i.jsx)(n.li,{children:"Even small contributions from secondary fields are preserved"}),"\n",(0,i.jsx)(n.li,{children:"Zero scores are avoided for fields that match the query"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This ensures that documents matching in multiple fields are correctly ranked higher than those matching in only one field, even when field boosts create large differences in raw score values."}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Field-Specific Searching"}),": Direct queries to specific fields when possible to improve relevance."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Combine Text Search with Filters"}),": Use filter nodes for non-scoring constraints to improve performance."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Boost Important Fields"}),": Use field boosting to prioritize matches in important fields like titles."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Prefer Term and Phrase Queries"}),": These are the most efficient. Use prefix and fuzzy queries sparingly."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use Direct Field Names for Range Queries"}),": For range queries, always use the direct field name (e.g., ",(0,i.jsx)(n.code,{children:'"word_count"'}),") and not the nested path (e.g., ",(0,i.jsx)(n.code,{children:'"metadata.word_count"'}),") even though the field may appear nested in document structure."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Debug with Explanations"}),": When relevance is unexpected, use the explanation feature to understand scoring."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Choose the Right Scoring Algorithm"}),": Match the algorithm to your content and search requirements."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Combine Query and Parameter Boosts Strategically"}),": Use query-specific boosts for term-level importance and field boosts in parameters for global field importance."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Use the Schema System"}),": Define a proper schema with field types and default boosts for consistent search behavior."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/api",children:"API Reference"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/examples",children:"Examples"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/performance",children:"Performance Tuning"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/docs/bm25l",children:"BM25L Documentation"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);