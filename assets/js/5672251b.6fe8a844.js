"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3815],{8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>r});var t=i(6540);const l={},a=t.createContext(l);function d(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),t.createElement(a.Provider,{value:n},e.children)}},9584:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"parallel-indexing","title":"Parallel Indexing","description":"Fast-Inverted-Index supports parallel indexing to dramatically improve performance on multi-core systems. This guide explains how to use the parallel indexing functionality.","source":"@site/docs/parallel_indexing.md","sourceDirName":".","slug":"/parallel-indexing","permalink":"/fast-inverted-index-docs/docs/parallel-indexing","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/parallel_indexing.md","tags":[],"version":"current","frontMatter":{"id":"parallel-indexing","title":"Parallel Indexing","sidebar_label":"Parallel Indexing"},"sidebar":"docs","previous":{"title":"Document Content Storage","permalink":"/fast-inverted-index-docs/docs/document-content-storage"},"next":{"title":"Text Field Search","permalink":"/fast-inverted-index-docs/docs/text-field-search"}}');var l=i(4848),a=i(8453);const d={id:"parallel-indexing",title:"Parallel Indexing",sidebar_label:"Parallel Indexing"},r="Parallel Indexing",s={},o=[{value:"Why Parallel Indexing?",id:"why-parallel-indexing",level:2},{value:"How Parallel Indexing Works",id:"how-parallel-indexing-works",level:2},{value:"Using Parallel Indexing in Rust",id:"using-parallel-indexing-in-rust",level:2},{value:"Adding Multiple Documents",id:"adding-multiple-documents",level:3},{value:"Adding Documents with Metadata",id:"adding-documents-with-metadata",level:3},{value:"Parallel Optimization",id:"parallel-optimization",level:3},{value:"Using Parallel Indexing in Python",id:"using-parallel-indexing-in-python",level:2},{value:"Adding Multiple Documents",id:"adding-multiple-documents-1",level:3},{value:"Adding Documents with Metadata",id:"adding-documents-with-metadata-1",level:3},{value:"Parallel Optimization",id:"parallel-optimization-1",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Batch Size",id:"batch-size",level:3},{value:"Thread Count",id:"thread-count",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Benchmarks",id:"benchmarks",level:2},{value:"Limitations",id:"limitations",level:2}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"parallel-indexing",children:"Parallel Indexing"})}),"\n",(0,l.jsx)(n.p,{children:"Fast-Inverted-Index supports parallel indexing to dramatically improve performance on multi-core systems. This guide explains how to use the parallel indexing functionality."}),"\n",(0,l.jsx)(n.h2,{id:"why-parallel-indexing",children:"Why Parallel Indexing?"}),"\n",(0,l.jsx)(n.p,{children:"For large document collections, indexing can be a time-consuming process. By leveraging multiple CPU cores, parallel indexing can provide significant speedups:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Throughput"}),": 2-8x faster indexing depending on your CPU cores"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Resource Utilization"}),": Better utilization of available system resources"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Scalability"}),": Linear performance scaling with additional cores"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"how-parallel-indexing-works",children:"How Parallel Indexing Works"}),"\n",(0,l.jsx)(n.p,{children:"The parallel indexing implementation follows these steps:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Document Partitioning"}),": Documents are split into batches and distributed across worker threads"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Parallel Processing"}),": Each worker thread processes its assigned documents, building a partial index"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Term Extraction"}),": Terms are extracted and occurrences are recorded in thread-local structures"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Merge Phase"}),": Partial indices are merged into the main index in a thread-safe manner"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Optimization"}),": The merged index is optimized for query performance"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"This approach ensures maximum parallelism while maintaining thread-safety."}),"\n",(0,l.jsx)(n.h2,{id:"using-parallel-indexing-in-rust",children:"Using Parallel Indexing in Rust"}),"\n",(0,l.jsx)(n.h3,{id:"adding-multiple-documents",children:"Adding Multiple Documents"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use fast_inverted_index::{Index, IndexBuilder, ParallelIndexing, ParallelIndexingConfig};\n\n// Create an index\nlet mut index = IndexBuilder::new()\n    .with_storage_path("/path/to/index")\n    .build()?;\n\n// Prepare documents\nlet documents = vec![\n    (1, "Document one content"),\n    (2, "Document two content"),\n    // ... more documents\n];\n\n// Configure parallel indexing\nlet config = ParallelIndexingConfig {\n    num_threads: 4,              // Use 4 threads (0 = use all available cores)\n    batch_size: 100,             // Process documents in batches of 100\n    channel_capacity: 16,        // Size of the channel buffer\n};\n\n// Index documents in parallel\nindex.add_documents_parallel(documents, Some(config))?;\n'})}),"\n",(0,l.jsx)(n.h3,{id:"adding-documents-with-metadata",children:"Adding Documents with Metadata"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:'use fast_inverted_index::{Index, IndexBuilder, ParallelIndexing, ParallelIndexingConfig};\nuse fast_inverted_index::common::DocumentMetadata;\n\n// Create an index\nlet mut index = IndexBuilder::new()\n    .with_storage_path("/path/to/index")\n    .build()?;\n\n// Prepare documents with metadata\nlet mut documents = Vec::new();\n\nfor i in 0..1000 {\n    let doc_id = i;\n    let content = format!("Document {i} content");\n    \n    let metadata = DocumentMetadata {\n        id: doc_id,\n        title: format!("Document {i}"),\n        author: Some("Author Name".to_string()),\n        tags: vec!["tag1".to_string(), "tag2".to_string()],\n        ..Default::default()\n    };\n    \n    documents.push((doc_id, content, metadata));\n}\n\n// Index documents in parallel\nindex.add_documents_with_metadata_parallel(documents, None)?;\n'})}),"\n",(0,l.jsx)(n.h3,{id:"parallel-optimization",children:"Parallel Optimization"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"use fast_inverted_index::{Index, ParallelOptimization};\n\n// Optimize using multiple threads\nindex.optimize_parallel(None)?;  // None = use all available cores\n"})}),"\n",(0,l.jsx)(n.h2,{id:"using-parallel-indexing-in-python",children:"Using Parallel Indexing in Python"}),"\n",(0,l.jsx)(n.h3,{id:"adding-multiple-documents-1",children:"Adding Multiple Documents"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index\n\n# Create an index\nindex = Index(storage_path="/path/to/index")\n\n# Prepare documents\ndocuments = [\n    (1, "Document one content"),\n    (2, "Document two content"),\n    # ... more documents\n]\n\n# Index documents in parallel\nindex.add_documents_parallel(\n    documents,\n    num_threads=4,     # Use 4 threads (None = use all available cores)\n    batch_size=100     # Process documents in batches of 100\n)\n'})}),"\n",(0,l.jsx)(n.h3,{id:"adding-documents-with-metadata-1",children:"Adding Documents with Metadata"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index\n\n# Create an index\nindex = Index(storage_path="/path/to/index")\n\n# Prepare documents with metadata\ndocuments = []\n\nfor i in range(1000):\n    doc_id = i\n    content = f"Document {i} content"\n    \n    metadata = {\n        "title": f"Document {i}",\n        "author": "Author Name",\n        "tags": ["tag1", "tag2"],\n        "category": "Example",\n        "language": "en",\n    }\n    \n    documents.append((doc_id, content, metadata))\n\n# Index documents in parallel\nindex.add_documents_with_metadata_parallel(\n    documents,\n    num_threads=None,   # Use all available cores\n    batch_size=100      # Process documents in batches of 100\n)\n'})}),"\n",(0,l.jsx)(n.h3,{id:"parallel-optimization-1",children:"Parallel Optimization"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index\n\n# Create and populate an index\nindex = Index(storage_path="/path/to/index")\n# ... add documents\n\n# Optimize using multiple threads\nindex.optimize_parallel(num_threads=None)  # None = use all available cores\n'})}),"\n",(0,l.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,l.jsx)(n.h3,{id:"batch-size",children:"Batch Size"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"batch_size"})," parameter controls how many documents are processed in a single batch. This affects performance:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Smaller batches"}),": Better load balancing but higher overhead"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Larger batches"}),": Less overhead but potentially uneven load distribution"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"A good starting point is 50-100 documents per batch. For very large documents, use smaller batches."}),"\n",(0,l.jsx)(n.h3,{id:"thread-count",children:"Thread Count"}),"\n",(0,l.jsxs)(n.p,{children:["While you can specify the exact number of threads, using ",(0,l.jsx)(n.code,{children:"None"})," (Python) or ",(0,l.jsx)(n.code,{children:"0"})," (Rust) automatically uses the optimal number based on your CPU:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"# Python - Auto-detect optimal thread count\nindex.add_documents_parallel(documents, num_threads=None)\n\n# Python - Specify exact thread count\nindex.add_documents_parallel(documents, num_threads=4)\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-rust",children:"// Rust - Auto-detect optimal thread count\nlet config = ParallelIndexingConfig {\n    num_threads: 0,  // 0 means auto-detect\n    batch_size: 100,\n    channel_capacity: 16,\n};\n\n// Rust - Specify exact thread count\nlet config = ParallelIndexingConfig {\n    num_threads: 4,\n    batch_size: 100,\n    channel_capacity: 16,\n};\n"})}),"\n",(0,l.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,l.jsx)(n.p,{children:"Parallel indexing uses more memory than sequential indexing because each worker thread maintains its own partial index. Consider these guidelines:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Ensure your system has sufficient RAM"}),"\n",(0,l.jsx)(n.li,{children:"For very large collections, use a larger batch size to control memory usage"}),"\n",(0,l.jsx)(n.li,{children:"Monitor memory usage during indexing"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,l.jsx)(n.p,{children:"See the provided example scripts for complete demonstrations:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"python/fast_inverted_index/examples/parallel_indexing_example.py"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"python/fast_inverted_index/examples/parallel_wikipedia_indexer.py"})}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"These scripts demonstrate real-world usage and provide benchmarks comparing sequential and parallel performance."}),"\n",(0,l.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,l.jsx)(n.p,{children:"After building the index, all query operations are thread-safe. Multiple threads can safely query the index concurrently without locking. The following operations can be performed concurrently:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"query()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"term_query()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"and_query()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"or_query()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"search()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"search_tfidf()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"search_bm25()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"suggest_terms()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"get_document()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"get_documents()"})}),"\n",(0,l.jsx)(n.li,{children:(0,l.jsx)(n.code,{children:"stats()"})}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Mutation operations like ",(0,l.jsx)(n.code,{children:"add_document()"}),", ",(0,l.jsx)(n.code,{children:"remove_document()"}),", and ",(0,l.jsx)(n.code,{children:"optimize()"})," are not thread-safe and should not be performed concurrently with other operations."]}),"\n",(0,l.jsx)(n.h2,{id:"benchmarks",children:"Benchmarks"}),"\n",(0,l.jsx)(n.p,{children:"In our testing, parallel indexing provides significant performance improvements:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"CPU"}),(0,l.jsx)(n.th,{children:"Sequential"}),(0,l.jsx)(n.th,{children:"Parallel (4 threads)"}),(0,l.jsx)(n.th,{children:"Speedup"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"4-core"}),(0,l.jsx)(n.td,{children:"100 docs/sec"}),(0,l.jsx)(n.td,{children:"350 docs/sec"}),(0,l.jsx)(n.td,{children:"3.5x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"8-core"}),(0,l.jsx)(n.td,{children:"120 docs/sec"}),(0,l.jsx)(n.td,{children:"680 docs/sec"}),(0,l.jsx)(n.td,{children:"5.7x"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"16-core"}),(0,l.jsx)(n.td,{children:"125 docs/sec"}),(0,l.jsx)(n.td,{children:"950 docs/sec"}),(0,l.jsx)(n.td,{children:"7.6x"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.em,{children:"Results may vary based on document size, content complexity, and system configuration."})}),"\n",(0,l.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,l.jsx)(n.p,{children:"While parallel indexing greatly improves performance, there are some limitations to be aware of:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Memory usage increases with the number of threads"}),"\n",(0,l.jsx)(n.li,{children:"Very small document collections may not benefit due to overhead"}),"\n",(0,l.jsx)(n.li,{children:"Some operations (like optimization) still have sequential components"}),"\n",(0,l.jsx)(n.li,{children:"Maximum effective speedup is limited by final merge phase"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"For most real-world applications with thousands of documents, parallel indexing provides substantial benefits that outweigh these limitations."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);