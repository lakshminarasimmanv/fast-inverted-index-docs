"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7676],{5259:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"memory-management","title":"Memory Management","description":"This document covers best practices and APIs for managing memory usage in the fast-inverted-index library.","source":"@site/docs/memory_management.md","sourceDirName":".","slug":"/memory-management","permalink":"/fast-inverted-index-docs/docs/memory-management","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/memory_management.md","tags":[],"version":"current","frontMatter":{"id":"memory-management","title":"Memory Management","sidebar_label":"Memory Management"},"sidebar":"docs","previous":{"title":"Hybrid Dictionary","permalink":"/fast-inverted-index-docs/docs/hybrid-dictionary"},"next":{"title":"Thread Safety","permalink":"/fast-inverted-index-docs/docs/thread-safety"}}');var i=r(4848),t=r(8453);const o={id:"memory-management",title:"Memory Management",sidebar_label:"Memory Management"},a="Memory Management in Fast Inverted Index",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Memory Growth Patterns",id:"memory-growth-patterns",level:2},{value:"Memory Management APIs",id:"memory-management-apis",level:2},{value:"Rust API",id:"rust-api",level:3},{value:"Python API",id:"python-api",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Proactive Memory Management",id:"1-proactive-memory-management",level:3},{value:"2. Memory Monitoring",id:"2-memory-monitoring",level:3},{value:"3. Limit Batch Sizes",id:"3-limit-batch-sizes",level:3},{value:"4. Proper Index Cleanup",id:"4-proper-index-cleanup",level:3},{value:"5. Clean Up After Complex Queries",id:"5-clean-up-after-complex-queries",level:3},{value:"Memory Footprint Reduction Techniques",id:"memory-footprint-reduction-techniques",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"High Memory Usage",id:"high-memory-usage",level:3},{value:"Cannot Close Index",id:"cannot-close-index",level:3},{value:"Implementation Details",id:"implementation-details",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"memory-management-in-fast-inverted-index",children:"Memory Management in Fast Inverted Index"})}),"\n",(0,i.jsx)(n.p,{children:"This document covers best practices and APIs for managing memory usage in the fast-inverted-index library."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The fast-inverted-index library maintains several in-memory data structures to achieve high performance:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Posting Lists Cache"}),": Stores recently accessed posting lists to improve search performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Field-Specific Memory Structures"}),": Stores field-specific posting lists for indexed fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Document Metadata"}),": Stores document information for quick access"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dictionary"}),": Maintains term-to-ID mappings with a tiered hot/medium/cold storage approach"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"While these structures are essential for performance, they can lead to increased memory usage in long-running applications. Version 0.4.4 introduces new tools to help manage memory effectively."}),"\n",(0,i.jsx)(n.h2,{id:"memory-growth-patterns",children:"Memory Growth Patterns"}),"\n",(0,i.jsx)(n.p,{children:"Memory usage can grow in the following ways:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Document Count"}),": As more documents are added, the index naturally requires more memory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cached Posting Lists"}),": Recently accessed terms stay in cache even if not used frequently"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Field Proliferation"}),": Indexes with many fields can accumulate memory in rarely used fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complex Queries"}),": Temporary objects created during complex query execution may persist"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"memory-management-apis",children:"Memory Management APIs"}),"\n",(0,i.jsx)(n.h3,{id:"rust-api",children:"Rust API"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// In the Index struct\nimpl Index {\n    // Manage memory usage by pruning cache and cleaning up rarely used fields\n    pub fn manage_memory(&mut self) -> Result<()>;\n    \n    // Get a memory usage estimate for monitoring\n    pub fn estimate_memory_usage(&self) -> HashMap<String, usize>;\n    \n    // Clean up resources after query execution\n    pub fn cleanup_after_query(&self) -> Result<()>;\n}\n\n// In the LruCache implementation\nimpl<K, V> LruCache<K, V> {\n    // Actively prune expired entries\n    pub fn prune(&self) -> usize;\n    \n    // Get an estimate of memory usage\n    pub fn estimate_size(&self) -> usize;\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"python-api",children:"Python API"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Index methods\nclass Index:\n    # Manage memory usage by pruning cache and cleaning up rarely used fields\n    def manage_memory(self): ...\n    \n    # Get memory usage statistics\n    def memory_usage(self) -> dict: ...\n    \n    # Close the index and release resources\n    def close(self): ...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"1-proactive-memory-management",children:"1. Proactive Memory Management"}),"\n",(0,i.jsxs)(n.p,{children:["For long-running applications, periodically call ",(0,i.jsx)(n.code,{children:"manage_memory()"})," to prevent unbounded growth:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Python example\nimport time\n\nindex = Index(storage_path="my_index")\n\n# Add documents, perform searches...\n\n# Every hour, clean up memory\nwhile True:\n    time.sleep(3600)  # 1 hour\n    index.manage_memory()\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// Rust example\nuse std::thread;\nuse std::time::Duration;\n\nlet mut index = Index::new()?;\n\n// Add documents, perform searches...\n\n// Clean up memory after batch operations\nindex.manage_memory()?;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-memory-monitoring",children:"2. Memory Monitoring"}),"\n",(0,i.jsx)(n.p,{children:"Track memory usage to detect issues early:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Python example\ndef log_memory_usage(index):\n    memory = index.memory_usage()\n    total_mb = memory["total"] / (1024 * 1024)\n    print(f"Memory usage: {total_mb:.2f} MB")\n    \n    if total_mb > 1000:  # 1 GB\n        print("Memory usage high, running cleanup")\n        index.manage_memory()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"3-limit-batch-sizes",children:"3. Limit Batch Sizes"}),"\n",(0,i.jsx)(n.p,{children:"Process documents in reasonable batches to allow for memory cleanup between batches:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Python example\ndocs = load_documents()  # Large dataset\n\n# Process in batches of 1000\nfor i in range(0, len(docs), 1000):\n    batch = docs[i:i+1000]\n    for doc in batch:\n        index.add_document(doc["id"], doc["content"])\n    \n    # Manage memory after each batch\n    index.manage_memory()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"4-proper-index-cleanup",children:"4. Proper Index Cleanup"}),"\n",(0,i.jsxs)(n.p,{children:["Always call ",(0,i.jsx)(n.code,{children:"close()"})," when done with an index to release resources:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Python example\ntry:\n    index = Index(storage_path="my_index")\n    # Use the index...\nfinally:\n    # Ensure resources are released\n    index.close()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"5-clean-up-after-complex-queries",children:"5. Clean Up After Complex Queries"}),"\n",(0,i.jsx)(n.p,{children:"For applications with complex, resource-intensive queries, clean up after each operation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Python example\n# Execute a complex query\ncomplex_query = QueryNode.AND([\n    QueryNode.term("title", "rust"),\n    QueryNode.OR([\n        QueryNode.term("content", "performance"),\n        QueryNode.term("content", "memory")\n    ])\n])\n\nresult = index.execute_query(complex_query)\n\n# Process results...\n\n# Clean up memory\nindex.manage_memory()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"memory-footprint-reduction-techniques",children:"Memory Footprint Reduction Techniques"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Field Selection"}),": Only index the fields you need to search"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Be Selective with Storage"}),": Use ",(0,i.jsx)(n.code,{children:"in_memory=False"})," for persistent storage with RocksDB"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Set Cache Size Appropriately"}),": Configure ",(0,i.jsx)(n.code,{children:"cache_size"})," based on available memory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use TTL for Cache"}),": Set ",(0,i.jsx)(n.code,{children:"cache_ttl_secs"})," for automatic expiration of cached entries"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Specialized Indices"}),": Create separate indices for different document types rather than one large index"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"high-memory-usage",children:"High Memory Usage"}),"\n",(0,i.jsx)(n.p,{children:"If memory usage is higher than expected:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Call ",(0,i.jsx)(n.code,{children:"memory_usage()"})," to identify which components are using memory"]}),"\n",(0,i.jsxs)(n.li,{children:["Call ",(0,i.jsx)(n.code,{children:"manage_memory()"})," to clean up unused resources"]}),"\n",(0,i.jsxs)(n.li,{children:["Reduce the ",(0,i.jsx)(n.code,{children:"cache_size"})," parameter when creating the index"]}),"\n",(0,i.jsxs)(n.li,{children:["Set a shorter cache TTL with ",(0,i.jsx)(n.code,{children:"cache_ttl_secs"})]}),"\n",(0,i.jsx)(n.li,{children:"Check if you're storing unnecessary fields"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"cannot-close-index",children:"Cannot Close Index"}),"\n",(0,i.jsx)(n.p,{children:"If you cannot close the index due to reference errors:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Make sure all query results and other objects are no longer referenced"}),"\n",(0,i.jsxs)(n.li,{children:["Force garbage collection by calling ",(0,i.jsx)(n.code,{children:"gc.collect()"})," in Python"]}),"\n",(0,i.jsx)(n.li,{children:"Check for circular references or leaked objects"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,i.jsx)(n.p,{children:"The memory management features use the following techniques:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The LRU cache uses Moka's ",(0,i.jsx)(n.code,{children:"run_pending_tasks()"})," to prune expired entries"]}),"\n",(0,i.jsx)(n.li,{children:"Field memory management identifies rarely used fields based on document counts"}),"\n",(0,i.jsx)(n.li,{children:"Memory usage estimation uses approximations based on collection sizes"}),"\n",(0,i.jsx)(n.li,{children:"The close method attempts to get exclusive ownership of the index to clean up"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By following these guidelines, you can use the fast-inverted-index library in long-running applications without memory concerns."})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var s=r(6540);const i={},t=s.createContext(i);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);