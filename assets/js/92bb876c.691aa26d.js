"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[9184],{2105:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"getting-started","title":"getting started","description":"This guide will help you get started with the Fast-Inverted-Index library for building high-performance search functionality in your applications.","source":"@site/docs/getting_started.md","sourceDirName":".","slug":"/getting-started","permalink":"/fast-inverted-index-docs/docs/getting-started","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/getting_started.md","tags":[],"version":"current","frontMatter":{"id":"getting-started","title":"getting started","sidebar_label":"getting started"},"sidebar":"docs","previous":{"title":"installation","permalink":"/fast-inverted-index-docs/docs/installation"},"next":{"title":"API Reference","permalink":"/fast-inverted-index-docs/docs/api"}}');var s=t(4848),r=t(8453);const d={id:"getting-started",title:"getting started",sidebar_label:"getting started"},a="Getting Started with Fast-Inverted-Index",o={},l=[{value:"Installation",id:"installation",level:2},{value:"Python",id:"python",level:3},{value:"Rust",id:"rust",level:3},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Quickstart",id:"quickstart",level:2},{value:"Basic Python Example",id:"basic-python-example",level:3},{value:"Python Example with Redis Content Storage",id:"python-example-with-redis-content-storage",level:3},{value:"Multi-Field Python Example",id:"multi-field-python-example",level:3},{value:"Basic Rust Example",id:"basic-rust-example",level:3},{value:"Multi-Field Rust Example",id:"multi-field-rust-example",level:3},{value:"Creating an Index",id:"creating-an-index",level:2},{value:"In-Memory Index",id:"in-memory-index",level:3},{value:"Persistent Index",id:"persistent-index",level:3},{value:"Adding Documents",id:"adding-documents",level:2},{value:"Basic Document",id:"basic-document",level:3},{value:"With Metadata",id:"with-metadata",level:3},{value:"Searching",id:"searching",level:2},{value:"Simple Queries",id:"simple-queries",level:3},{value:"Parsed Queries",id:"parsed-queries",level:3},{value:"Ranked Search",id:"ranked-search",level:3},{value:"Term Suggestions",id:"term-suggestions",level:2},{value:"Index Management",id:"index-management",level:2},{value:"Statistics",id:"statistics",level:3},{value:"Optimization",id:"optimization",level:3},{value:"Backup",id:"backup",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"getting-started-with-fast-inverted-index",children:"Getting Started with Fast-Inverted-Index"})}),"\n",(0,s.jsx)(n.p,{children:"This guide will help you get started with the Fast-Inverted-Index library for building high-performance search functionality in your applications."}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,s.jsx)(n.p,{children:"Install from PyPI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pip install fast-inverted-index\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rust",children:"Rust"}),"\n",(0,s.jsxs)(n.p,{children:["Add to your ",(0,s.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\nfast-inverted-index = "0.4.6"\n'})}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rust 1.58 or later (if using Rust API)"}),"\n",(0,s.jsx)(n.li,{children:"Python 3.7 or later (if using Python API)"}),"\n",(0,s.jsx)(n.li,{children:"For Python, the library includes pre-built wheels for common platforms"}),"\n",(0,s.jsx)(n.li,{children:"For building from source, you'll need a C++ compiler and RocksDB development libraries"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"quickstart",children:"Quickstart"}),"\n",(0,s.jsx)(n.h3,{id:"basic-python-example",children:"Basic Python Example"}),"\n",(0,s.jsx)(n.p,{children:"Create a simple search engine in Python:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index\n\n# Create an index\nindex = Index(in_memory=True)\n\n# Add some documents\nindex.add_document(1, "Python is a programming language")\nindex.add_document(2, "Rust is a systems programming language")\nindex.add_document(3, "Search engines use inverted indices")\n\n# Search for documents\nresults = index.search("programming")\nprint(f"Found {len(results)} results for \'programming\'")\n\n# Print the matching document IDs and scores\nfor doc_id, score in results:\n    print(f"Document ID: {doc_id}, Score: {score:.4f}")\n    doc = index.get_document(doc_id)\n    print(f"Metadata: {doc}")\n\n# Get term suggestions\nsuggestions = index.suggest_terms("pro")\nprint("Suggestions for \'pro\':")\nfor suggestion in suggestions:\n    print(f"  {suggestion[\'term\']} (score: {suggestion[\'score\']})")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"python-example-with-redis-content-storage",children:"Python Example with Redis Content Storage"}),"\n",(0,s.jsx)(n.p,{children:"Create a search engine with Redis for content storage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import json\nimport redis\nfrom fast_inverted_index import Index\n\n# Connect to Redis\nredis_client = redis.Redis(host=\'localhost\', port=6379, db=0)\nredis_prefix = "search:"\n\n# Create an index\nindex = Index(in_memory=True)\n\n# Function to add a document with Redis content storage\ndef add_document(doc_id, content, metadata=None):\n    # Add to index for searching\n    index.add_document(doc_id, content, metadata or {})\n    \n    # Store full content in Redis\n    redis_client.set(\n        f"{redis_prefix}doc:{doc_id}",\n        json.dumps({"content": content, "metadata": metadata or {}})\n    )\n\n# Function to retrieve a document with content\ndef get_document(doc_id):\n    # Get metadata from index\n    doc_metadata = index.get_document(doc_id)\n    \n    # Get content from Redis\n    redis_data = redis_client.get(f"{redis_prefix}doc:{doc_id}")\n    if redis_data:\n        content_data = json.loads(redis_data)\n        # Combine metadata and content\n        return {**doc_metadata, "content": content_data["content"]}\n    \n    return doc_metadata  # Fall back to just metadata\n\n# Add some documents\nadd_document(\n    1, \n    "Python is a programming language with simple, easy-to-learn syntax.",\n    {"title": "Introduction to Python", "tags": ["python", "programming"]}\n)\n\nadd_document(\n    2, \n    "Rust provides memory safety without garbage collection, making it ideal for systems programming.",\n    {"title": "Rust Systems Programming", "tags": ["rust", "programming", "systems"]}\n)\n\n# Search for documents\nresults = index.search("programming")\nprint(f"Found {len(results)} results for \'programming\'")\n\n# Retrieve and display results with content\nfor doc_id, score in results:\n    # Get document with content from Redis\n    doc = get_document(doc_id)\n    \n    print(f"\\nDocument ID: {doc_id}, Score: {score:.4f}")\n    print(f"Title: {doc.get(\'title\', \'No title\')}")\n    print(f"Tags: {\', \'.join(doc.get(\'tags\', []))}")\n    \n    # Display content snippet\n    content = doc.get("content", "")\n    if len(content) > 100:\n        content = content[:100] + "..."\n    print(f"Content: {content}")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multi-field-python-example",children:"Multi-Field Python Example"}),"\n",(0,s.jsx)(n.p,{children:"Create a search engine with field-specific indexing and searching:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index, Schema, FieldSchema, QueryNode, QueryExecutionParams\n\n# Create a schema with different field types\nschema = Schema()\nschema.add_field(FieldSchema.text("title").with_boost(5.0))    # Title field gets 5x boost\nschema.add_field(FieldSchema.text("content").with_boost(1.0))  # Content field has normal importance\nschema.add_field(FieldSchema.keyword("tags").with_boost(3.0))  # Tags field gets 3x boost, uses keyword analyzer\nschema.set_default_field("content")  # Default field for queries that don\'t specify a field\n\n# Create an index with the schema\nindex = Index(in_memory=True, schema=schema)\n\n# Add documents with fields\ndoc1_fields = {\n    "title": "Introduction to Python",\n    "content": "Python is a high-level programming language with simple syntax.",\n    "tags": "programming python tutorial"\n}\nindex.add_document_with_fields(1, doc1_fields)\n\ndoc2_fields = {\n    "title": "Rust Systems Programming",\n    "content": "Rust provides memory safety without garbage collection.",\n    "tags": "programming rust systems"\n}\nindex.add_document_with_fields(2, doc2_fields)\n\ndoc3_fields = {\n    "title": "Search Engine Technology",\n    "content": "Search engines commonly use inverted indices for efficient retrieval.",\n    "tags": "search indexing information-retrieval"\n}\nindex.add_document_with_fields(3, doc3_fields)\n\n# Search in a specific field\ntitle_results = index.search_field("title", "Python", ranking_method="bm25", limit=10)\nprint(f"Documents with \'Python\' in title: {len(title_results)}")\n\n# Search across all fields with different boosts\nboost_fields = {\n    "title": 5.0,    # Title matches are 5x more important\n    "content": 1.0,  # Content matches have normal importance\n    "tags": 3.0      # Tag matches are 3x more important\n}\nresults = index.search("programming", ranking_method="bm25", boost_fields=boost_fields)\nprint(f"Documents about \'programming\' across all fields: {len(results)}")\n\n# Advanced query using QueryNode API\nquery = QueryNode.OR([\n    QueryNode.term("title", "search", boost=5.0),    # Search in title with 5x boost\n    QueryNode.term("content", "inverted", boost=1.0),  # Search in content with normal importance\n    QueryNode.term("tags", "indexing", boost=3.0)    # Search in tags with 3x boost\n])\n\nparams = QueryExecutionParams(\n    scoring_algorithm="bm25",\n    limit=10\n)\n\nquery_results = index.execute_query(query, params)\nprint(f"Documents matching complex query: {len(query_results.scored_docs)}")\n\n# Get the first matching document\nfor doc_id, score in query_results.scored_docs:\n    doc = index.get_document(doc_id)\n    print(f"Document ID: {doc_id}, Score: {score:.4f}")\n    print(f"Title: {doc.get(\'title\', \'Untitled\')}")\n    print(f"Tags: {doc.get(\'tags\', [])}")\n    break\n'})}),"\n",(0,s.jsx)(n.h3,{id:"basic-rust-example",children:"Basic Rust Example"}),"\n",(0,s.jsx)(n.p,{children:"Create a search engine in Rust:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use fast_inverted_index::{IndexBuilder, Query};\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // Create an in-memory index\n    let mut index = IndexBuilder::new()\n        .with_in_memory(true)\n        .build()?;\n    \n    // Add some documents\n    index.add_document(1, "Rust is a systems programming language")?;\n    index.add_document(2, "Fast and reliable code with memory safety")?;\n    index.add_document(3, "Search engines commonly use inverted indices")?;\n    \n    // Search for documents\n    let query = Query::term("programming");\n    let results = index.query(&query)?;\n    \n    println!("Found {} documents containing \'programming\'", results.doc_ids.len());\n    println!("Document IDs: {:?}", results.doc_ids);\n    \n    // Get term suggestions\n    let suggestions = index.suggest_terms("pro")?;\n    println!("Suggestions for \'pro\':");\n    for suggestion in suggestions {\n        println!("  {} (score: {})", suggestion.term, suggestion.score);\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multi-field-rust-example",children:"Multi-Field Rust Example"}),"\n",(0,s.jsx)(n.p,{children:"Create a search engine with field-specific indexing and searching in Rust:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use fast_inverted_index::{\n    IndexBuilder,\n    schema::{Schema, SchemaBuilder, FieldSchema, FieldType, AnalyzerType},\n    query::{QueryNode, QueryExecutionParams, ScoringAlgorithm}\n};\nuse std::collections::HashMap;\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    // Create a schema with different field types\n    let schema = SchemaBuilder::new()\n        .add_field(FieldSchema::text("title").with_boost(5.0))\n        .add_field(FieldSchema::text("content").with_boost(1.0))\n        .add_field(FieldSchema::keyword("tags").with_boost(3.0))\n        .default_field("content")\n        .build();\n    \n    // Create an index with the schema\n    let mut index = IndexBuilder::new()\n        .with_in_memory(true)\n        .with_schema(schema)\n        .build()?;\n    \n    // Add documents with fields\n    let mut doc1_fields = HashMap::new();\n    doc1_fields.insert("title".to_string(), "Introduction to Python".to_string());\n    doc1_fields.insert("content".to_string(), "Python is a high-level programming language with simple syntax.".to_string());\n    doc1_fields.insert("tags".to_string(), "programming python tutorial".to_string());\n    index.add_document_with_fields(1, doc1_fields)?;\n    \n    let mut doc2_fields = HashMap::new();\n    doc2_fields.insert("title".to_string(), "Rust Systems Programming".to_string());\n    doc2_fields.insert("content".to_string(), "Rust provides memory safety without garbage collection.".to_string());\n    doc2_fields.insert("tags".to_string(), "programming rust systems".to_string());\n    index.add_document_with_fields(2, doc2_fields)?;\n    \n    // Multi-field search using QueryNode API\n    let query = QueryNode::or(vec![\n        QueryNode::term_with_boost("title", "programming", 5.0),\n        QueryNode::term_with_boost("content", "programming", 1.0),\n        QueryNode::term_with_boost("tags", "programming", 3.0)\n    ]);\n    \n    // Create execution parameters\n    let mut params = QueryExecutionParams {\n        scoring_algorithm: ScoringAlgorithm::BM25,\n        limit: Some(10),\n        ..Default::default()\n    };\n    \n    // Add field boosts\n    let mut field_boosts = HashMap::new();\n    field_boosts.insert("title".to_string(), 1.5);\n    field_boosts.insert("tags".to_string(), 1.2);\n    params.field_boosts = field_boosts;\n    \n    // Execute the query\n    let results = index.execute_query(&query, Some(params))?;\n    \n    println!("Found {} documents matching the query", results.scored_docs.len());\n    for (doc_id, score) in &results.scored_docs {\n        println!("Document {}: Score {:.4}", doc_id, score);\n    }\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"creating-an-index",children:"Creating an Index"}),"\n",(0,s.jsx)(n.h3,{id:"in-memory-index",children:"In-Memory Index"}),"\n",(0,s.jsx)(n.p,{children:"For temporary search needs, create an in-memory index:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Python\nindex = Index(in_memory=True)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Rust\nlet index = IndexBuilder::new()\n    .with_in_memory(true)\n    .build()?;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"persistent-index",children:"Persistent Index"}),"\n",(0,s.jsx)(n.p,{children:"For persistent storage, specify a storage path:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python\nindex = Index(storage_path="/path/to/index")\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nlet index = IndexBuilder::new()\n    .with_storage_path("/path/to/index")\n    .build()?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"adding-documents",children:"Adding Documents"}),"\n",(0,s.jsx)(n.p,{children:"Documents are the core units of searchable content. Each document has a unique ID and content text."}),"\n",(0,s.jsx)(n.h3,{id:"basic-document",children:"Basic Document"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python\nindex.add_document(1, "Document content text")\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nindex.add_document(1, "Document content text")?;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"with-metadata",children:"With Metadata"}),"\n",(0,s.jsx)(n.p,{children:"Add rich metadata to improve search relevance and result presentation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python\nindex.add_document(\n    doc_id=1,\n    content="Document content text",\n    metadata={\n        "title": "Document Title",\n        "author": "Author Name",\n        "tags": ["tag1", "tag2"],\n        "category": "Example",\n        "language": "en"\n    }\n)\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nuse fast_inverted_index::common::DocumentMetadata;\n\nindex.add_document_with_metadata(\n    1,\n    "Document content text",\n    DocumentMetadata {\n        id: 1,\n        title: "Document Title".to_string(),\n        author: Some("Author Name".to_string()),\n        tags: vec!["tag1".to_string(), "tag2".to_string()],\n        category: Some("Example".to_string()),\n        language: "en".to_string(),\n        ..Default::default()\n    }\n)?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"searching",children:"Searching"}),"\n",(0,s.jsx)(n.p,{children:"The library provides multiple ways to search for documents."}),"\n",(0,s.jsx)(n.h3,{id:"simple-queries",children:"Simple Queries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python - Single term query\nresults = index.term_query("search")\n\n# AND query - documents containing all terms\nresults = index.and_query(["search", "engine"])\n\n# OR query - documents containing any term\nresults = index.or_query(["search", "index"])\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust - Single term query\nlet query = Query::term("search");\nlet results = index.query(&query)?;\n\n// AND query\nlet query = Query::and(vec!["search".to_string(), "engine".to_string()]);\nlet results = index.query(&query)?;\n\n// OR query\nlet query = Query::or(vec!["search".to_string(), "index".to_string()]);\nlet results = index.query(&query)?;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"parsed-queries",children:"Parsed Queries"}),"\n",(0,s.jsx)(n.p,{children:"Parse query strings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python\nresults = index.parse_query("search engine")  # AND query by default\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nlet query = Query::parse("search engine");  // AND query by default\nlet results = index.query(&query)?;\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ranked-search",children:"Ranked Search"}),"\n",(0,s.jsx)(n.p,{children:"Get results with relevance ranking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python\nresults = index.search("search engine", ranking_method="bm25")\n\n# With field boosting\nresults = index.search_with_metadata(\n    "search engine",\n    ranking_method="bm25",\n    boost_fields={"title": 2.0, "tags": 1.5},\n    limit=10\n)\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nlet query = Query::parse("search engine");\n\n// BM25 ranking\nlet results = index.search_bm25(&query, None)?;\n\n// With field boosting\nlet mut boosts = std::collections::HashMap::new();\nboosts.insert("title".to_string(), 2.0);\nboosts.insert("tags".to_string(), 1.5);\nlet results = index.search_bm25(&query, Some(boosts))?;\n\n// TF-IDF ranking\nlet results = index.search_tfidf(&query, None)?;\n'})}),"\n",(0,s.jsx)(n.h2,{id:"term-suggestions",children:"Term Suggestions"}),"\n",(0,s.jsx)(n.p,{children:"Generate autocomplete suggestions from term prefixes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Python\nsuggestions = index.suggest_terms(\"prog\")\n\n# Print suggestions\nfor suggestion in suggestions:\n    print(f\"{suggestion['term']} (score: {suggestion['score']})\")\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nlet suggestions = index.suggest_terms("prog")?;\n\n// Print suggestions\nfor suggestion in &suggestions {\n    println!("{} (score: {})", suggestion.term, suggestion.score);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"index-management",children:"Index Management"}),"\n",(0,s.jsx)(n.h3,{id:"statistics",children:"Statistics"}),"\n",(0,s.jsx)(n.p,{children:"Get information about the index:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Python\nstats = index.stats()\nprint(f\"Documents: {stats['document_count']}\")\nprint(f\"Terms: {stats['term_count']}\")\nprint(f\"Cache hit rate: {stats['cache_hit_rate']}\")\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nlet stats = index.stats()?;\nprintln!("Documents: {}", stats.document_count);\nprintln!("Terms: {}", stats.term_count);\nprintln!("Cache hit rate: {}", stats.cache_hit_rate);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"optimization",children:"Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Optimize the index for better performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Python\nindex.optimize()\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Rust\nindex.optimize()?;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"backup",children:"Backup"}),"\n",(0,s.jsx)(n.p,{children:"Create a backup of the index:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Python\nindex.backup("/path/to/backup")\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Rust\nindex.backup(std::path::PathBuf::from("/path/to/backup"))?;\n'})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function d(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);