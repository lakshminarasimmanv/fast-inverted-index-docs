"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[6020],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const o={},d=i.createContext(o);function r(e){const n=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(d.Provider,{value:n},e.children)}},8536:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"document-content-storage","title":"Document Content Storage","description":"This document explains how document content is handled in the Fast Inverted Index library and provides best practices for content retrieval.","source":"@site/docs/document_content_storage.md","sourceDirName":".","slug":"/document-content-storage","permalink":"/fast-inverted-index-docs/docs/document-content-storage","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/document_content_storage.md","tags":[],"version":"current","frontMatter":{"id":"document-content-storage","title":"Document Content Storage","sidebar_label":"Document Content Storage"},"sidebar":"docs","previous":{"title":"Thread Safety","permalink":"/fast-inverted-index-docs/docs/thread-safety"},"next":{"title":"Parallel Indexing","permalink":"/fast-inverted-index-docs/docs/parallel-indexing"}}');var o=t(4848),d=t(8453);const r={id:"document-content-storage",title:"Document Content Storage",sidebar_label:"Document Content Storage"},s="Document Content Storage in Fast Inverted Index",c={},a=[{value:"How Content is Handled",id:"how-content-is-handled",level:2},{value:"Retrieving Documents",id:"retrieving-documents",level:2},{value:"Best Practices for Content Retrieval",id:"best-practices-for-content-retrieval",level:2},{value:"1. Store Content Externally",id:"1-store-content-externally",level:3},{value:"2. Include Content in Fields",id:"2-include-content-in-fields",level:3},{value:"3. Use a Storage-Enabled Index Implementation",id:"3-use-a-storage-enabled-index-implementation",level:3},{value:"Example Implementation",id:"example-implementation",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"document-content-storage-in-fast-inverted-index",children:"Document Content Storage in Fast Inverted Index"})}),"\n",(0,o.jsx)(n.p,{children:"This document explains how document content is handled in the Fast Inverted Index library and provides best practices for content retrieval."}),"\n",(0,o.jsx)(n.h2,{id:"how-content-is-handled",children:"How Content is Handled"}),"\n",(0,o.jsxs)(n.p,{children:["When adding documents to the Fast Inverted Index, the content is ",(0,o.jsx)(n.strong,{children:"indexed"})," but not ",(0,o.jsx)(n.strong,{children:"stored directly"})," in the index. This distinction is important to understand:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Indexing"}),": The content is analyzed, tokenized, and added to the inverted index for searching."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Storage"}),": The content itself is not stored in a way that can be directly retrieved."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This design choice has several implications:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The index is more efficient and compact"}),"\n",(0,o.jsx)(n.li,{children:"Searches against content work as expected"}),"\n",(0,o.jsx)(n.li,{children:"Document metadata is preserved and retrievable"}),"\n",(0,o.jsx)(n.li,{children:"The original content must be stored separately if retrieval is needed"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"retrieving-documents",children:"Retrieving Documents"}),"\n",(0,o.jsxs)(n.p,{children:["When you retrieve a document using ",(0,o.jsx)(n.code,{children:"get_document(doc_id)"}),", you get a dictionary containing:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'{\n  "id": 1,\n  "title": "Document Title",\n  "author": "Author Name",\n  "tags": ["tag1", "tag2"],\n  "language": "en",\n  "created_at": 1234567890,\n  "updated_at": 1234567890,\n  "metadata": {\n    "word_count": 150,\n    "reading_time": 45,\n    "byte_length": 750\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Notice that the full document content is not included in this structure."}),"\n",(0,o.jsx)(n.h2,{id:"best-practices-for-content-retrieval",children:"Best Practices for Content Retrieval"}),"\n",(0,o.jsx)(n.h3,{id:"1-store-content-externally",children:"1. Store Content Externally"}),"\n",(0,o.jsx)(n.p,{children:"Store the original document content in a separate storage system:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'# Content store could be a database, file system, or in-memory dictionary\ncontent_store = {}\n\n# When adding documents\ndoc_id = 1\ncontent = "This is the document content..."\nfields = {"title": "Document Title", "author": "Author Name"}\n\n# Store in index\nindex.add_document(doc_id, content, fields)\n\n# Store content separately\ncontent_store[doc_id] = content\n\n# When retrieving documents\nsearch_results = index.search("query")\nfor doc_id, score in search_results:\n    doc_metadata = index.get_document(doc_id)\n    full_content = content_store[doc_id]\n    \n    print(f"Title: {doc_metadata[\'title\']}")\n    print(f"Score: {score}")\n    print(f"Content: {full_content}")\n'})}),"\n",(0,o.jsx)(n.h3,{id:"2-include-content-in-fields",children:"2. Include Content in Fields"}),"\n",(0,o.jsx)(n.p,{children:"If you need the content retrievable directly from the index, include it in the fields dictionary:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'doc_id = 1\ncontent = "This is the document content..."\nfields = {\n    "title": "Document Title",\n    "author": "Author Name",\n    "content": content  # Duplicate content in fields\n}\n\n# Store in index with content both as primary content and in fields\nindex.add_document(doc_id, content, fields)\n\n# When retrieving\ndoc = index.get_document(doc_id)\nif "content" in doc:\n    print(f"Content: {doc[\'content\']}")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["However, in our testing, we found that the ",(0,o.jsx)(n.code,{children:"content"})," field is not reliably preserved when using this approach."]}),"\n",(0,o.jsx)(n.h3,{id:"3-use-a-storage-enabled-index-implementation",children:"3. Use a Storage-Enabled Index Implementation"}),"\n",(0,o.jsx)(n.p,{children:"Some search engines (like Elasticsearch) provide both indexing and storage capabilities. If you need full content retrieval, consider:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Using a different search engine implementation"}),"\n",(0,o.jsx)(n.li,{children:"Building a storage layer on top of Fast Inverted Index"}),"\n",(0,o.jsx)(n.li,{children:"Implementing a document store integration"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,o.jsx)(n.p,{children:"A typical implementation might look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class SearchSystem:\n    def __init__(self):\n        self.index = Index(in_memory=True)\n        self.document_store = {}  # Could be a database\n    \n    def add_document(self, doc_id, content, metadata):\n        # Index for searching\n        self.index.add_document(doc_id, content, metadata)\n        # Store for retrieval\n        self.document_store[doc_id] = {\n            "content": content,\n            "metadata": metadata\n        }\n    \n    def search(self, query, limit=10):\n        # Search the index\n        results = self.index.search(query, limit=limit)\n        \n        # Enrich results with content\n        enriched_results = []\n        for doc_id, score in results:\n            metadata = self.index.get_document(doc_id)\n            content = self.document_store[doc_id]["content"]\n            \n            enriched_results.append({\n                "id": doc_id,\n                "score": score,\n                "metadata": metadata,\n                "content": content\n            })\n            \n        return enriched_results\n'})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"The Fast Inverted Index library is primarily designed for efficient searching rather than document storage. For a complete search system, you'll need to implement a separate storage layer to preserve and retrieve document content."}),"\n",(0,o.jsx)(n.p,{children:"This separation of concerns is common in search system design, allowing each component to be optimized for its specific purpose: the index for fast searching and the document store for content retrieval."})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);