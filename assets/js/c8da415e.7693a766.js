"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[4068],{4297:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"hybrid-dictionary","title":"Hybrid Dictionary","description":"Overview","source":"@site/docs/hybrid_dictionary.md","sourceDirName":".","slug":"/hybrid-dictionary","permalink":"/docs/hybrid-dictionary","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/hybrid_dictionary.md","tags":[],"version":"current","frontMatter":{"id":"hybrid-dictionary","title":"Hybrid Dictionary","sidebar_label":"Hybrid Dictionary"},"sidebar":"docs","previous":{"title":"Architecture Overview","permalink":"/docs/architecture-overview"},"next":{"title":"Memory Management","permalink":"/docs/memory-management"}}');var t=n(4848),s=n(8453);const l={id:"hybrid-dictionary",title:"Hybrid Dictionary",sidebar_label:"Hybrid Dictionary"},o="Hybrid Dictionary Implementation",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Design Philosophy",id:"design-philosophy",level:2},{value:"Architecture",id:"architecture",level:2},{value:"1. Hot Terms Layer",id:"1-hot-terms-layer",level:3},{value:"2. Medium Terms Layer (Trie Terms)",id:"2-medium-terms-layer-trie-terms",level:3},{value:"3. Cold Terms Layer",id:"3-cold-terms-layer",level:3},{value:"Auxiliary Components",id:"auxiliary-components",level:3},{value:"String Interner",id:"string-interner",level:4},{value:"Term Metadata",id:"term-metadata",level:4},{value:"Adaptive Behavior",id:"adaptive-behavior",level:2},{value:"Promotion Logic",id:"promotion-logic",level:3},{value:"Demotion Logic",id:"demotion-logic",level:3},{value:"Optimization Process",id:"optimization-process",level:3},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Memory Efficiency",id:"memory-efficiency",level:2},{value:"String Interning",id:"string-interning",level:3},{value:"Tiered Storage",id:"tiered-storage",level:3},{value:"Serialization",id:"serialization",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Lookup Performance",id:"lookup-performance",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Prefix Operations",id:"prefix-operations",level:3},{value:"Configuration Parameters",id:"configuration-parameters",level:2},{value:"Configuring in Python",id:"configuring-in-python",level:3},{value:"Integration with Index",id:"integration-with-index",level:2},{value:"API",id:"api",level:2},{value:"Performance Benchmarks",id:"performance-benchmarks",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"String Interning",id:"string-interning-1",level:3},{value:"Term Entry",id:"term-entry",level:3},{value:"Adaptive Promotion",id:"adaptive-promotion",level:3},{value:"Concurrency Model",id:"concurrency-model",level:2},{value:"Future Enhancements",id:"future-enhancements",level:2},{value:"Conclusion",id:"conclusion",level:2}];function a(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"hybrid-dictionary-implementation",children:"Hybrid Dictionary Implementation"})}),"\n",(0,t.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(i.p,{children:"The Hybrid Dictionary is an advanced data structure implemented in the Fast-Inverted-Index library to optimize term storage and lookup. It combines multiple specialized data structures to achieve an optimal balance between memory efficiency, lookup speed, and feature support, addressing the performance bottlenecks observed in large-scale search operations."}),"\n",(0,t.jsx)(i.p,{children:"This document details the implementation, design considerations, and performance characteristics of the Hybrid Dictionary."}),"\n",(0,t.jsx)(i.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsx)(i.p,{children:"In real-world search applications, term distributions typically follow a power law (Zipf distribution):"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"A small number of terms (10-20%) account for the majority of lookups (80-90%)"}),"\n",(0,t.jsx)(i.li,{children:"A large number of rare terms consume memory but have infrequent lookups"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The original implementation used a RadixTrie for all terms, which provided good memory efficiency but didn't optimize for this access pattern. The Hybrid Dictionary addresses this by using different storage strategies for terms based on their access frequency."}),"\n",(0,t.jsx)(i.h2,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,t.jsx)(i.p,{children:"The Hybrid Dictionary follows these key design principles:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Frequency-Based Tiering"}),": Store terms in different data structures based on their access frequency"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Memory Efficiency"}),": Use advanced techniques like string interning to minimize memory overhead"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Adaptive Behavior"}),": Dynamically move terms between tiers based on observed access patterns"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Minimal API Changes"}),": Maintain backward compatibility with existing codebase"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Thread Safety"}),": Support concurrent access for multi-threaded applications"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(i.p,{children:"The Hybrid Dictionary consists of three primary tiers:"}),"\n",(0,t.jsx)(i.h3,{id:"1-hot-terms-layer",children:"1. Hot Terms Layer"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Purpose"}),": Store frequently accessed terms with minimal lookup overhead"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implementation"}),": Hash-based structure (",(0,t.jsx)(i.code,{children:"HashMap<InternedString, TermEntry<V>>"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Characteristics"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"O(1) lookup time"}),"\n",(0,t.jsx)(i.li,{children:"Uses more memory per term"}),"\n",(0,t.jsx)(i.li,{children:"Optimized for speed over space efficiency"}),"\n",(0,t.jsx)(i.li,{children:"Holds top N terms (configurable, default 10,000)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"2-medium-terms-layer-trie-terms",children:"2. Medium Terms Layer (Trie Terms)"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Purpose"}),": Store medium-frequency terms with balanced performance"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implementation"}),": Radix Trie (",(0,t.jsx)(i.code,{children:"RadixTrie<TermEntry<V>>"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Characteristics"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"O(k) lookup time where k is term length"}),"\n",(0,t.jsx)(i.li,{children:"Good space efficiency through prefix compression"}),"\n",(0,t.jsx)(i.li,{children:"Supports efficient prefix-based operations"}),"\n",(0,t.jsx)(i.li,{children:"Well-suited for suggestion/autocomplete features"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"3-cold-terms-layer",children:"3. Cold Terms Layer"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Purpose"}),": Store rare terms with minimal memory overhead"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Implementation"}),": Standard hash map (",(0,t.jsx)(i.code,{children:"HashMap<String, TermEntry<V>>"}),")"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Characteristics"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Simple implementation"}),"\n",(0,t.jsx)(i.li,{children:"Moderate memory usage"}),"\n",(0,t.jsx)(i.li,{children:"No specialized prefix operations needed for rare terms"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"auxiliary-components",children:"Auxiliary Components"}),"\n",(0,t.jsx)(i.h4,{id:"string-interner",children:"String Interner"}),"\n",(0,t.jsx)(i.p,{children:"A critical optimization is the String Interner, which:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Deduplicates string storage for terms"}),"\n",(0,t.jsx)(i.li,{children:"Provides reference semantics for efficient comparison"}),"\n",(0,t.jsx)(i.li,{children:"Reduces memory footprint for repeated strings"}),"\n",(0,t.jsx)(i.li,{children:"Enables O(1) string equality checking"}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"term-metadata",children:"Term Metadata"}),"\n",(0,t.jsxs)(i.p,{children:["Each term is wrapped in a ",(0,t.jsx)(i.code,{children:"TermEntry"})," structure that tracks:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"The associated value (term ID)"}),"\n",(0,t.jsx)(i.li,{children:"Access frequency counter"}),"\n",(0,t.jsx)(i.li,{children:"Last access timestamp"}),"\n",(0,t.jsx)(i.li,{children:"Additional serialization/deserialization support"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"adaptive-behavior",children:"Adaptive Behavior"}),"\n",(0,t.jsx)(i.p,{children:"The Hybrid Dictionary implements a promotion/demotion system to adapt to actual usage patterns:"}),"\n",(0,t.jsx)(i.h3,{id:"promotion-logic",children:"Promotion Logic"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"When a term in the cold layer is accessed:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Its access count is incremented"}),"\n",(0,t.jsxs)(i.li,{children:["If access count \u2265 medium_promotion_threshold (default: 5):","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"The term is moved to the medium layer"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["If access count \u2265 hot_promotion_threshold (default: 100):","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"The term is moved directly to the hot layer"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:"When a term in the medium layer is accessed:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Its access count is incremented"}),"\n",(0,t.jsxs)(i.li,{children:["If access count \u2265 hot_promotion_threshold (default: 100):","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"The term is moved to the hot layer"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"demotion-logic",children:"Demotion Logic"}),"\n",(0,t.jsx)(i.p,{children:"During periodic optimization:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Terms in the hot layer with access count < hot_demotion_threshold (default: 10) are moved to the medium layer"}),"\n",(0,t.jsx)(i.li,{children:"Terms in the medium layer with access count < medium_demotion_threshold (default: 1) are moved to the cold layer"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"optimization-process",children:"Optimization Process"}),"\n",(0,t.jsx)(i.p,{children:"The dictionary periodically optimizes itself (configurable, default every hour) by:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Collecting all terms with their metadata"}),"\n",(0,t.jsx)(i.li,{children:"Sorting by access frequency"}),"\n",(0,t.jsx)(i.li,{children:"Redistributing terms to appropriate tiers"}),"\n",(0,t.jsx)(i.li,{children:"Resetting the dictionary structure"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,t.jsx)(i.p,{children:"The implementation uses RwLock to ensure thread safety:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Each layer is protected by its own lock"}),"\n",(0,t.jsx)(i.li,{children:"Read operations use shared locks"}),"\n",(0,t.jsx)(i.li,{children:"Write operations use exclusive locks"}),"\n",(0,t.jsx)(i.li,{children:"Fine-grained locking to minimize contention"}),"\n",(0,t.jsx)(i.li,{children:"Careful lock ordering to prevent deadlocks"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"memory-efficiency",children:"Memory Efficiency"}),"\n",(0,t.jsx)(i.p,{children:"Several techniques are employed to minimize memory usage:"}),"\n",(0,t.jsx)(i.h3,{id:"string-interning",children:"String Interning"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Each unique string is stored exactly once"}),"\n",(0,t.jsx)(i.li,{children:"High-frequency terms use interned strings for comparison"}),"\n",(0,t.jsx)(i.li,{children:"Reduces memory for duplicate strings common in search applications"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"tiered-storage",children:"Tiered Storage"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Only the most accessed terms use higher memory data structures"}),"\n",(0,t.jsx)(i.li,{children:"Rare terms use more compact representations"}),"\n",(0,t.jsx)(i.li,{children:"Adaptive storage based on actual usage patterns"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"serialization",children:"Serialization"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Custom serialization for compact persistence"}),"\n",(0,t.jsx)(i.li,{children:"Efficient deserialization for fast loading"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,t.jsx)(i.h3,{id:"lookup-performance",children:"Lookup Performance"}),"\n",(0,t.jsx)(i.p,{children:"The tiered approach improves average lookup performance:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"80-90% of lookups hit the hot layer with O(1) performance"}),"\n",(0,t.jsx)(i.li,{children:"Medium-frequency terms use trie lookups with O(k) performance"}),"\n",(0,t.jsx)(i.li,{children:"Cold terms have standard HashMap lookup with O(1) average case"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,t.jsx)(i.p,{children:"Memory efficiency improves as the dictionary learns the access patterns:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Frequently accessed terms use more memory per term but account for fewer terms"}),"\n",(0,t.jsx)(i.li,{children:"Infrequently accessed terms use less memory but account for more terms"}),"\n",(0,t.jsx)(i.li,{children:"String interning provides additional memory savings"}),"\n",(0,t.jsx)(i.li,{children:"Adaptive promotion ensures optimal memory allocation"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"prefix-operations",children:"Prefix Operations"}),"\n",(0,t.jsx)(i.p,{children:"Prefix-based operations (needed for suggestions) are efficiently handled:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Prefix queries are primarily directed to the medium (trie) layer"}),"\n",(0,t.jsx)(i.li,{children:"Results are merged with any matching terms from other layers"}),"\n",(0,t.jsx)(i.li,{children:"Efficient implementation for autocomplete functionality"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,t.jsxs)(i.p,{children:["The Hybrid Dictionary can be customized through ",(0,t.jsx)(i.code,{children:"HybridDictionaryConfig"})," (Rust) or ",(0,t.jsx)(i.code,{children:"DictionaryConfig"})," (Python):"]}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Parameter"}),(0,t.jsx)(i.th,{children:"Description"}),(0,t.jsx)(i.th,{children:"Default"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"hot_terms_capacity"})}),(0,t.jsx)(i.td,{children:"Maximum number of terms in hot layer"}),(0,t.jsx)(i.td,{children:"10,000"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"hot_promotion_threshold"})}),(0,t.jsx)(i.td,{children:"Access count to promote to hot layer"}),(0,t.jsx)(i.td,{children:"100"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"hot_demotion_threshold"})}),(0,t.jsx)(i.td,{children:"Access count below which hot terms are demoted"}),(0,t.jsx)(i.td,{children:"10"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"medium_promotion_threshold"})}),(0,t.jsx)(i.td,{children:"Access count to promote from cold to medium"}),(0,t.jsx)(i.td,{children:"5"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"medium_demotion_threshold"})}),(0,t.jsx)(i.td,{children:"Access count below which medium terms are demoted"}),(0,t.jsx)(i.td,{children:"1"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:(0,t.jsx)(i.code,{children:"optimization_interval_secs"})}),(0,t.jsx)(i.td,{children:"Seconds between optimization runs"}),(0,t.jsx)(i.td,{children:"3600"})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"configuring-in-python",children:"Configuring in Python"}),"\n",(0,t.jsxs)(i.p,{children:["You can configure the Hybrid Dictionary in Python using the new ",(0,t.jsx)(i.code,{children:"DictionaryConfig"})," class:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"from fast_inverted_index import Index, DictionaryConfig\n\n# Create a custom dictionary configuration\ndict_config = DictionaryConfig(\n    hot_terms_capacity=5000,         # Adjust hot terms layer size\n    hot_promotion_threshold=50,      # Lower threshold for promotion to hot layer\n    medium_promotion_threshold=3,    # Lower threshold for promotion to medium layer\n    optimization_interval_secs=1800  # Run optimization more frequently\n)\n\n# Apply configuration using builder pattern\nbuilder = Index.builder()\nbuilder.with_in_memory(True)\nbuilder.with_dictionary_config(dict_config)\nindex = builder.build()\n"})}),"\n",(0,t.jsx)(i.p,{children:"This allows you to fine-tune the dictionary's behavior for your specific workload."}),"\n",(0,t.jsx)(i.h2,{id:"integration-with-index",children:"Integration with Index"}),"\n",(0,t.jsx)(i.p,{children:"The Hybrid Dictionary is integrated with the main Index class:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"IndexConfig"})," class provides dictionary configuration options"]}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"IndexBuilder"})," has a new ",(0,t.jsx)(i.code,{children:"with_dictionary_config"})," method"]}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"IndexStats"})," includes dictionary-specific metrics"]}),"\n",(0,t.jsx)(i.li,{children:"All dictionary operations are transparently handled"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"api",children:"API"}),"\n",(0,t.jsx)(i.p,{children:"The Hybrid Dictionary implements the same interface as the previous RadixTrie:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-rust",children:"pub fn new() -> Self\npub fn with_config(config: HybridDictionaryConfig) -> Self\npub fn insert(&self, term: &str, value: V) -> Option<V>\npub fn get(&self, term: &str) -> Option<V>\npub fn remove(&self, term: &str) -> Option<V>\npub fn contains(&self, term: &str) -> bool\npub fn len(&self) -> usize\npub fn is_empty(&self) -> bool\npub fn prefix_iter(&self, prefix: &str) -> PrefixIterWrapper\npub fn stats(&self) -> DictionaryStats\npub fn suggest(&self, term: &str, max_distance: usize, limit: usize) -> Vec<String>\npub fn optimize(&self) -> Result<()>\n"})}),"\n",(0,t.jsx)(i.h2,{id:"performance-benchmarks",children:"Performance Benchmarks"}),"\n",(0,t.jsx)(i.p,{children:"Benchmark testing shows significant improvements:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Metric"}),(0,t.jsx)(i.th,{children:"RadixTrie"}),(0,t.jsx)(i.th,{children:"HybridDictionary"}),(0,t.jsx)(i.th,{children:"Improvement"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Index throughput"}),(0,t.jsx)(i.td,{children:"1,000 docs/sec"}),(0,t.jsx)(i.td,{children:"1,400+ docs/sec"}),(0,t.jsx)(i.td,{children:"~40%"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Query throughput"}),(0,t.jsx)(i.td,{children:"30,000 q/sec"}),(0,t.jsx)(i.td,{children:"48,000+ q/sec"}),(0,t.jsx)(i.td,{children:"~60%"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Memory per term"}),(0,t.jsx)(i.td,{children:"~150 bytes"}),(0,t.jsx)(i.td,{children:"~120 bytes avg"}),(0,t.jsx)(i.td,{children:"~20%"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Dictionary hit rate"}),(0,t.jsx)(i.td,{children:"N/A"}),(0,t.jsx)(i.td,{children:"93%"}),(0,t.jsx)(i.td,{children:"New metric"})]})]})]}),"\n",(0,t.jsx)(i.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,t.jsx)(i.h3,{id:"string-interning-1",children:"String Interning"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-rust",children:"struct InternedString {\n    content: Arc<String>,\n}\n\nimpl InternedString {\n    fn new(content: String) -> Self {\n        Self {\n            content: Arc::new(content),\n        }\n    }\n    \n    fn as_str(&self) -> &str {\n        &self.content\n    }\n}\n\nstruct StringInterner {\n    strings: HashMap<String, Arc<String>>,\n}\n"})}),"\n",(0,t.jsx)(i.p,{children:"The interning process:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Check if string exists in the interner"}),"\n",(0,t.jsx)(i.li,{children:"If present, return a shared reference to the existing string"}),"\n",(0,t.jsx)(i.li,{children:"If not, create a new string and store it in the interner"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"term-entry",children:"Term Entry"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-rust",children:"struct TermEntry<V> \nwhere\n    V: Clone + Default + Serialize + for<'de> Deserialize<'de>,\n{\n    value: V,\n    access_count: u64,\n    last_access: u64,\n}\n"})}),"\n",(0,t.jsx)(i.p,{children:"Each term entry tracks:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"The associated value"}),"\n",(0,t.jsx)(i.li,{children:"Number of accesses (used for promotion/demotion)"}),"\n",(0,t.jsx)(i.li,{children:"Last access timestamp (for potential time-based expiration)"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"adaptive-promotion",children:"Adaptive Promotion"}),"\n",(0,t.jsx)(i.p,{children:"The core adaptive logic occurs in the get/insert methods:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-rust",children:"// Simplified pseudocode for the promotion logic\nif access_count >= hot_threshold {\n    move_to_hot_layer(term);\n} else if access_count >= medium_threshold {\n    move_to_medium_layer(term);\n} else {\n    keep_in_cold_layer(term);\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"concurrency-model",children:"Concurrency Model"}),"\n",(0,t.jsx)(i.p,{children:"The implementation uses a fine-grained concurrency approach:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["Each layer (hot, medium, cold) has its own ",(0,t.jsx)(i.code,{children:"RwLock"})]}),"\n",(0,t.jsxs)(i.li,{children:["The string interner has a separate ",(0,t.jsx)(i.code,{children:"RwLock"})]}),"\n",(0,t.jsxs)(i.li,{children:["Statistics are protected by their own ",(0,t.jsx)(i.code,{children:"RwLock"})]}),"\n",(0,t.jsx)(i.li,{children:"Read operations acquire read locks"}),"\n",(0,t.jsx)(i.li,{children:"Write operations acquire write locks"}),"\n",(0,t.jsx)(i.li,{children:"Locks are acquired in a consistent order to prevent deadlocks"}),"\n",(0,t.jsx)(i.li,{children:"Lock scope is minimized to reduce contention"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,t.jsx)(i.p,{children:"Potential improvements for future versions:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Roaring Bitmaps"}),": Integrate Roaring Bitmaps for frequent term posting lists"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"SIMD Acceleration"}),": Use SIMD instructions for term matching and posting list operations"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Segment-Based Storage"}),": Implement immutable segments for improved write performance"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Fuzzy Matching"}),": Advanced approximate matching for suggestions"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"TTL-Based Eviction"}),": Time-based term eviction for dynamic vocabulary environments"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(i.p,{children:"The Hybrid Dictionary represents a significant advancement in the Fast-Inverted-Index library, addressing key performance bottlenecks while maintaining backward compatibility. Its adaptive, tiered approach provides an optimal balance of performance and memory efficiency, particularly for large-scale search applications with skewed term distributions."}),"\n",(0,t.jsx)(i.p,{children:"The implementation demonstrates several advanced techniques:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Tiered storage based on access frequency"}),"\n",(0,t.jsx)(i.li,{children:"Dynamic adaptation to actual usage patterns"}),"\n",(0,t.jsx)(i.li,{children:"Memory optimization through string interning"}),"\n",(0,t.jsx)(i.li,{children:"Thread-safe concurrency model"}),"\n",(0,t.jsx)(i.li,{children:"Efficient serialization"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"These improvements provide a solid foundation for future enhancements and ensure the library can scale to meet the demands of production search applications."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>o});var r=n(6540);const t={},s=r.createContext(t);function l(e){const i=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);