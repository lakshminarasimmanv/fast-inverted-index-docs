"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[5728],{5112:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"rocksdb_optimization","title":"RocksDB Optimization Guide","description":"This guide covers the optimized RocksDB storage backend added in version 0.4.7 of Fast Inverted Index. The optimizations significantly improve indexing and query performance when using persistent storage.","source":"@site/docs/rocksdb_optimization.md","sourceDirName":".","slug":"/rocksdb_optimization","permalink":"/docs/rocksdb_optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/username/fast-inverted-index/tree/main/docusaurus/docs/rocksdb_optimization.md","tags":[],"version":"current","frontMatter":{"id":"rocksdb_optimization","title":"RocksDB Optimization Guide","sidebar_label":"RocksDB Optimization"}}');var t=i(4848),s=i(8453);const o={id:"rocksdb_optimization",title:"RocksDB Optimization Guide",sidebar_label:"RocksDB Optimization"},a="RocksDB Optimization Guide",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"Optimizing for Different Workloads",id:"optimizing-for-different-workloads",level:2},{value:"Bulk Loading",id:"bulk-loading",level:3},{value:"Read-Heavy Workloads",id:"read-heavy-workloads",level:3},{value:"Balanced Approach",id:"balanced-approach",level:3},{value:"Using Bulk Loading Mode",id:"using-bulk-loading-mode",level:2},{value:"Column Family Optimization",id:"column-family-optimization",level:2},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Python Integration",id:"python-integration",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"rocksdb-optimization-guide",children:"RocksDB Optimization Guide"})}),"\n",(0,t.jsx)(n.p,{children:"This guide covers the optimized RocksDB storage backend added in version 0.4.7 of Fast Inverted Index. The optimizations significantly improve indexing and query performance when using persistent storage."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Fast Inverted Index uses RocksDB as its persistent storage backend. RocksDB is a high-performance embedded key-value store designed for SSD storage. Our optimized implementation provides significant performance improvements, especially for bulk indexing operations."}),"\n",(0,t.jsx)(n.p,{children:"Key optimizations include:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"WriteBatch Support"})," - Consolidate multiple operations into atomic batches"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bulk Loading Mode"})," - Disable WAL for maximum performance during initial loading"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Column Family Tuning"})," - Optimized settings for different data types"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread-Safe Wrappers"})," - Robust multi-threading support for Python bindings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance Metrics"})," - Detailed instrumentation for monitoring"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch Operations"})," - High-level batch APIs for document operations"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RocksDbConfig"})," struct provides comprehensive options for tuning RocksDB performance:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"pub struct RocksDbConfig {\n    // Base path for the database\n    pub path: PathBuf,\n    \n    // Whether to create a new database if one doesn't exist\n    pub create_if_missing: bool,\n    \n    // Maximum number of open files\n    pub max_open_files: i32,\n    \n    // Write buffer size in bytes\n    pub write_buffer_size: usize,\n    \n    // Maximum number of write buffers\n    pub max_write_buffer_number: i32,\n    \n    // Target file size in bytes\n    pub target_file_size_base: u64,\n    \n    // Whether to disable WAL during bulk loading\n    pub disable_wal_for_bulk: bool,\n    \n    // Whether to use write batching\n    pub use_write_batch: bool,\n    \n    // Batch size for write operations\n    pub write_batch_size: usize,\n    \n    // Maximum background jobs for compaction\n    pub max_background_jobs: i32,\n    \n    // Whether to enable statistics\n    pub enable_statistics: bool,\n    \n    // Whether to optimize for bulk loading\n    pub optimize_for_bulk: bool,\n    \n    // Interval to flush batches even if not full\n    pub batch_flush_interval: Option<Duration>,\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"optimizing-for-different-workloads",children:"Optimizing for Different Workloads"}),"\n",(0,t.jsx)(n.h3,{id:"bulk-loading",children:"Bulk Loading"}),"\n",(0,t.jsx)(n.p,{children:"For initial data loading or batch imports, optimize for maximum write throughput:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let config = RocksDbConfig {\n    path: "/path/to/index".into(),\n    \n    // Increase write buffer for better batching\n    write_buffer_size: 128 * 1024 * 1024, // 128 MB\n    max_write_buffer_number: 6,\n    \n    // Enable bulk loading optimizations\n    disable_wal_for_bulk: true,\n    use_write_batch: true,\n    write_batch_size: 10000, // Large batch size\n    optimize_for_bulk: true,\n    \n    // More background jobs for better parallelism\n    max_background_jobs: 8,\n    \n    // Other settings at defaults\n    ..Default::default()\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"read-heavy-workloads",children:"Read-Heavy Workloads"}),"\n",(0,t.jsx)(n.p,{children:"For query-intensive applications, optimize for read performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let config = RocksDbConfig {\n    path: "/path/to/index".into(),\n    \n    // More file descriptors for better read performance\n    max_open_files: 2000,\n    \n    // Keep write buffer reasonable\n    write_buffer_size: 32 * 1024 * 1024, // 32 MB\n    \n    // Enable batching but with smaller batches\n    use_write_batch: true,\n    write_batch_size: 100,\n    \n    // No WAL disabling for safety\n    disable_wal_for_bulk: false,\n    \n    // Other settings at defaults\n    ..Default::default()\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"balanced-approach",children:"Balanced Approach"}),"\n",(0,t.jsx)(n.p,{children:"For balanced performance with both reads and writes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'let config = RocksDbConfig {\n    path: "/path/to/index".into(),\n    \n    // Moderate file descriptor count\n    max_open_files: 1000,\n    \n    // Moderate write buffer\n    write_buffer_size: 64 * 1024 * 1024, // 64 MB\n    max_write_buffer_number: 4,\n    \n    // Enable batching with medium batch size\n    use_write_batch: true,\n    write_batch_size: 1000,\n    \n    // Enable WAL for safety\n    disable_wal_for_bulk: false,\n    \n    // Other settings at defaults\n    ..Default::default()\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"using-bulk-loading-mode",children:"Using Bulk Loading Mode"}),"\n",(0,t.jsx)(n.p,{children:"The bulk loading mode is particularly useful for initial data loading or large batch operations. It significantly improves write performance by disabling the Write-Ahead Log (WAL) and applying other optimizations."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"// Create store with configuration\nlet mut store = RocksDbStore::with_config(config)?;\n\n// Enable bulk loading mode before large indexing operation\nstore.set_bulk_loading_mode(true);\n\n// Perform your bulk indexing operations...\n// This will be significantly faster\n\n// Disable bulk loading mode when finished (important for durability)\nstore.set_bulk_loading_mode(false);\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Important"}),": When bulk loading mode is enabled with WAL disabled, there is a risk of data loss if the process crashes during indexing. Always disable bulk loading mode and perform a backup when the operation completes."]}),"\n",(0,t.jsx)(n.h2,{id:"column-family-optimization",children:"Column Family Optimization"}),"\n",(0,t.jsx)(n.p,{children:"Different column families are optimized for their specific data and access patterns:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CF_DOCS"})," (document metadata) - Optimized for random access with LZ4 compression"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CF_TERMS"})," (term dictionary) - Configured with prefix bloom filters for efficient lookups"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CF_POSTINGS"})," (posting lists) - Optimized for sequential writes and reads"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CF_TERM_STATS"})," (term statistics) - Standard configuration for small key-value pairs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CF_METADATA"})," (index metadata) - Standard configuration for occasional access"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,t.jsx)(n.p,{children:"The storage layer collects detailed metrics to help identify bottlenecks:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Get statistics summary\nlet stats_summary = store.metrics.summary();\nprintln!("{}", stats_summary);\n\n// Access individual metrics\nlet write_count = store.metrics.write_count.load(Ordering::Relaxed);\nlet avg_batch_size = store.metrics.avg_items_per_batch();\nlet avg_write_time = store.metrics.avg_write_time_us();\n'})}),"\n",(0,t.jsx)(n.p,{children:"Available metrics include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Write counts and timing"}),"\n",(0,t.jsx)(n.li,{children:"Read counts and timing"}),"\n",(0,t.jsx)(n.li,{children:"Batch operation statistics"}),"\n",(0,t.jsx)(n.li,{children:"WAL flush metrics"}),"\n",(0,t.jsx)(n.li,{children:"Compaction metrics"}),"\n",(0,t.jsx)(n.li,{children:"Column family operation counts"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"python-integration",children:"Python Integration"}),"\n",(0,t.jsx)(n.p,{children:"The optimized RocksDB implementation is fully available through the Python bindings:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from fast_inverted_index import Index, Schema, FieldSchema\n\n# Create schema\nschema = Schema()\nschema.add_field(FieldSchema.text("content"))\n\n# Create index with RocksDB storage and optimized config\nindex = Index(\n    storage_path="/path/to/index",\n    in_memory=False,  # Use RocksDB storage\n    schema=schema\n)\n\n# The Python bindings automatically use batched operations\n# when adding multiple documents\n\n# Add documents in batch for better performance\ndocuments = [\n    (1, {"content": "Document 1 content"}),\n    (2, {"content": "Document 2 content"}),\n    # ...more documents\n]\n\n# This will use the optimized batch operations internally\nindex.add_documents_with_fields_parallel(documents)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Batched Operations"})," - Always prefer batch operations over individual document operations when possible."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Tune for Your Hardware"})," - Adjust settings based on available RAM, CPU cores, and storage type:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"SSDs: Larger write buffers, more background jobs"}),"\n",(0,t.jsx)(n.li,{children:"HDDs: Smaller, more frequent compactions, smaller batches"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Monitor Performance"})," - Track metrics to identify bottlenecks and adjust configurations accordingly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Backup Regularly"})," - Create periodic backups, especially after bulk loading operations."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Scale the Write Buffer"})," - For machines with more RAM, increase the write buffer size for better performance."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"High Write Latency"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Check if batching is enabled (",(0,t.jsx)(n.code,{children:"use_write_batch: true"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Consider increasing write buffer size"}),"\n",(0,t.jsx)(n.li,{children:"Enable bulk loading mode for initial imports"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"High Memory Usage"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reduce write buffer size and number"}),"\n",(0,t.jsx)(n.li,{children:"Reduce batch size"}),"\n",(0,t.jsx)(n.li,{children:"Consider tuning bloom filter sizes"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Slow Reads"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Ensure max_open_files is set appropriately"}),"\n",(0,t.jsx)(n.li,{children:"Check if bloom filters are properly configured"}),"\n",(0,t.jsx)(n.li,{children:"Verify proper column family settings"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Database Size Issues"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Run periodic compactions"}),"\n",(0,t.jsx)(n.li,{children:"Consider adjusting compression settings"}),"\n",(0,t.jsx)(n.li,{children:"Check if WAL is properly flushed"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The optimized RocksDB storage backend significantly improves the performance of Fast Inverted Index, especially for bulk operations. By properly configuring the RocksDB settings for your specific workload, you can achieve optimal performance for both indexing and querying operations."}),"\n",(0,t.jsxs)(n.p,{children:["For more information about general performance tuning, see the ",(0,t.jsx)(n.a,{href:"/docs/performance",children:"Performance Tuning Guide"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);